        -:    0:Source:gzip-1.2.4.c.reduced.c
        -:    0:Graph:gzip-1.2.4.c.reduced.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1:typedef void *voidp;
        -:    2:typedef unsigned char uch;
        -:    3:typedef unsigned short ush;
        -:    4:typedef unsigned long ulg;
        -:    5:typedef long __off_t;
        -:    6:typedef long __off64_t;
        -:    7:typedef long __ssize_t;
        -:    8:typedef __ssize_t ssize_t;
        -:    9:typedef unsigned long size_t;
        -:   10:struct _IO_FILE;
        -:   11:struct _IO_FILE;
        -:   12:typedef struct _IO_FILE FILE;
        -:   13:typedef void _IO_lock_t;
        -:   14:struct _IO_marker {
        -:   15:  struct _IO_marker *_next;
        -:   16:  struct _IO_FILE *_sbuf;
        -:   17:  int _pos;
        -:   18:};
        -:   19:struct _IO_FILE {
        -:   20:  int _flags;
        -:   21:  char *_IO_read_ptr;
        -:   22:  char *_IO_read_end;
        -:   23:  char *_IO_read_base;
        -:   24:  char *_IO_write_base;
        -:   25:  char *_IO_write_ptr;
        -:   26:  char *_IO_write_end;
        -:   27:  char *_IO_buf_base;
        -:   28:  char *_IO_buf_end;
        -:   29:  char *_IO_save_base;
        -:   30:  char *_IO_backup_base;
        -:   31:  char *_IO_save_end;
        -:   32:  struct _IO_marker *_markers;
        -:   33:  struct _IO_FILE *_chain;
        -:   34:  int _fileno;
        -:   35:  int _flags2;
        -:   36:  __off_t _old_offset;
        -:   37:  unsigned short _cur_column;
        -:   38:  signed char _vtable_offset;
        -:   39:  char _shortbuf[1];
        -:   40:  _IO_lock_t *_lock;
        -:   41:  __off64_t _offset;
        -:   42:  void *__pad1;
        -:   43:  void *__pad2;
        -:   44:  void *__pad3;
        -:   45:  void *__pad4;
        -:   46:  size_t __pad5;
        -:   47:  int _mode;
        -:   48:  char _unused2[(15UL * sizeof(int) - 4UL * sizeof(void *)) - sizeof(size_t)];
        -:   49:};
        -:   50:typedef unsigned char char_type;
        -:   51:typedef long code_int;
        -:   52:typedef unsigned long cmp_code_int;
        -:   53:typedef struct _IO_FILE _IO_FILE;
        -:   54:struct huft;
        -:   55:union __anonunion_v_25 {
        -:   56:  ush n;
        -:   57:  struct huft *t;
        -:   58:};
        -:   59:struct huft {
        -:   60:  uch e;
        -:   61:  uch b;
        -:   62:  union __anonunion_v_25 v;
        -:   63:};
        -:   64:typedef int file_t;
        -:   65:union __anonunion_fc_7 {
        -:   66:  ush freq;
        -:   67:  ush code;
        -:   68:};
        -:   69:union __anonunion_dl_8 {
        -:   70:  ush dad;
        -:   71:  ush len;
        -:   72:};
        -:   73:struct ct_data {
        -:   74:  union __anonunion_fc_7 fc;
        -:   75:  union __anonunion_dl_8 dl;
        -:   76:};
        -:   77:typedef struct ct_data ct_data;
        -:   78:struct tree_desc {
        -:   79:  ct_data *dyn_tree;
        -:   80:  ct_data *static_tree;
        -:   81:  int *extra_bits;
        -:   82:  int extra_base;
        -:   83:  int elems;
        -:   84:  int max_length;
        -:   85:  int max_code;
        -:   86:};
        -:   87:typedef struct tree_desc tree_desc;
        -:   88:typedef ush Pos;
        -:   89:typedef unsigned int IPos;
        -:   90:struct config {
        -:   91:  ush good_length;
        -:   92:  ush max_lazy;
        -:   93:  ush nice_length;
        -:   94:  ush max_chain;
        -:   95:};
        -:   96:typedef struct config config;
        -:   97:typedef unsigned long __dev_t;
        -:   98:typedef unsigned int __uid_t;
        -:   99:typedef unsigned int __gid_t;
        -:  100:typedef unsigned long __ino_t;
        -:  101:typedef unsigned int __mode_t;
        -:  102:typedef unsigned long __nlink_t;
        -:  103:typedef long __time_t;
        -:  104:typedef long __blksize_t;
        -:  105:typedef long __blkcnt_t;
        -:  106:typedef long __syscall_slong_t;
        -:  107:typedef __off_t off_t;
        -:  108:typedef __time_t time_t;
        -:  109:struct timespec {
        -:  110:  __time_t tv_sec;
        -:  111:  __syscall_slong_t tv_nsec;
        -:  112:};
        -:  113:typedef void (*__sighandler_t)(int);
        -:  114:struct stat {
        -:  115:  __dev_t st_dev;
        -:  116:  __ino_t st_ino;
        -:  117:  __nlink_t st_nlink;
        -:  118:  __mode_t st_mode;
        -:  119:  __uid_t st_uid;
        -:  120:  __gid_t st_gid;
        -:  121:  int __pad0;
        -:  122:  __dev_t st_rdev;
        -:  123:  __off_t st_size;
        -:  124:  __blksize_t st_blksize;
        -:  125:  __blkcnt_t st_blocks;
        -:  126:  struct timespec st_atim;
        -:  127:  struct timespec st_mtim;
        -:  128:  struct timespec st_ctim;
        -:  129:  __syscall_slong_t __glibc_reserved[3];
        -:  130:};
        -:  131:struct option {
        -:  132:  char const *name;
        -:  133:  int has_arg;
        -:  134:  int *flag;
        -:  135:  int val;
        -:  136:};
        -:  137:struct dirent {
        -:  138:  __ino_t d_ino;
        -:  139:  __off_t d_off;
        -:  140:  unsigned short d_reclen;
        -:  141:  unsigned char d_type;
        -:  142:  char d_name[256];
        -:  143:};
        -:  144:struct __dirstream;
        -:  145:struct __dirstream;
        -:  146:typedef struct __dirstream DIR;
        -:  147:typedef struct dirent dir_type;
        -:  148:struct utimbuf {
        -:  149:  __time_t actime;
        -:  150:  __time_t modtime;
        -:  151:};
        -:  152:uch inbuf[32832];
        -:  153:uch outbuf[18432];
        -:  154:ush d_buf[32768];
        -:  155:uch window[65536L];
        -:  156:ush prev[1L << 16];
        -:  157:unsigned int insize;
        -:  158:unsigned int inptr;
        -:  159:int ifd;
        -:  160:int ofd;
        -:  161:
        -:  162:int unlzh(int in, int out);
        -:  163:int fill_inbuf(int eof_ok);
        -:  164:void write_buf(int fd, voidp buf, unsigned int cnt);
        -:  165:void error(char *m);
        -:  166:static unsigned int decode(unsigned int count, uch *buffer);
        -:  167:static void decode_start(void);
        -:  168:static void huf_decode_start(void);
        -:  169:static unsigned int decode_c(void);
        -:  170:static unsigned int decode_p(void);
        -:  171:static void read_pt_len(int nn, int nbit, int i_special);
        -:  172:static void read_c_len(void);
        -:  173:static void fillbuf(int n);
        -:  174:static unsigned int getbits(int n);
        -:  175:static void init_getbits(void);
        -:  176:static void make_table(int nchar, uch *bitlen, int tablebits, ush *table);
        -:  177:
        -:  178:unsigned int outcnt;
        -:  179:
        -:  180:
        -:  181:
        -:  182:
        -:  183:int unpack(int in, int out);
        -:  184:void flush_window(void);
        -:  185:
        -:  186:static void read_tree(void);
        -:  187:static void build_tree(void);
        -:  188:
        -:  189:extern ssize_t read(int __fd, void *__buf, size_t __nbytes);
        -:  190:extern struct _IO_FILE *stderr;
        -:  191:extern int fprintf(FILE *__restrict __stream, char const *__restrict __format,
        -:  192:                   ...);
        -:  193:extern __attribute__((__nothrow__)) void *(
        -:  194:    __attribute__((__nonnull__(1, 2), __leaf__))
        -:  195:    memcpy)(void *__restrict __dest, void const *__restrict __src, size_t __n);
        -:  196:extern
        -:  197:    __attribute__((__nothrow__)) void *(__attribute__((__nonnull__(1),
        -:  198:                                                       __leaf__))
        -:  199:                                        memset)(void *__s, int __c, size_t __n);
        -:  200:long bytes_in;
        -:  201:char ifname[1024];
        -:  202:char *progname;
        -:  203:
        -:  204:void read_error(void);
        -:  205:
        -:  206:int unlzw(int in, int out);
        -:  207:
        -:  208:int lzw(int in, int out);
        -:  209:
        -:  210:extern __attribute__((__nothrow__)) unsigned short const **(
        -:  211:    __attribute__((__leaf__)) __ctype_b_loc)(void)__attribute__((__const__));
        -:  212:extern __attribute__((__nothrow__)) int *(
        -:  213:    __attribute__((__leaf__)) __errno_location)(void)__attribute__((__const__));
        -:  214:extern ssize_t write(int __fd, void const *__buf, size_t __n);
        -:  215:extern __attribute__((__nothrow__)) void *(__attribute__((__leaf__))
        -:  216:                                           malloc)(size_t __size)
        -:  217:    __attribute__((__malloc__));
        -:  218:extern
        -:  219:    __attribute__((__nothrow__)) void *(__attribute__((__leaf__))
        -:  220:                                        calloc)(size_t __nmemb, size_t __size)
        -:  221:        __attribute__((__malloc__));
        -:  222:extern __attribute__((__nothrow__)) void(__attribute__((__leaf__))
        -:  223:                                         free)(void *__ptr);
        -:  224:extern __attribute__((__nothrow__)) char *(__attribute__((__nonnull__(1),
        -:  225:                                                          __leaf__))
        -:  226:                                           getenv)(char const *__name);
        -:  227:extern int _IO_putc(int __c, _IO_FILE *__fp);
        -:  228:extern void perror(char const *__s);
        -:  229:extern __attribute__((__nothrow__)) char *(
        -:  230:    __attribute__((__nonnull__(1, 2), __leaf__))
        -:  231:    strcpy)(char *__restrict __dest, char const *__restrict __src);
        -:  232:extern __attribute__((__nothrow__)) char *(__attribute__((__nonnull__(1),
        -:  233:                                                          __leaf__))
        -:  234:                                           strrchr)(char const *__s, int __c)
        -:  235:    __attribute__((__pure__));
        -:  236:extern __attribute__((__nothrow__))
        -:  237:size_t(__attribute__((__nonnull__(1, 2), __leaf__))
        -:  238:       strcspn)(char const *__s, char const *__reject)
        -:  239:    __attribute__((__pure__));
        -:  240:extern __attribute__((__nothrow__))
        -:  241:size_t(__attribute__((__nonnull__(1, 2), __leaf__))
        -:  242:       strspn)(char const *__s, char const *__accept) __attribute__((__pure__));
        -:  243:extern __attribute__((__nothrow__))
        -:  244:size_t(__attribute__((__nonnull__(1), __leaf__)) strlen)(char const *__s)
        -:  245:    __attribute__((__pure__));
        -:  246:char ofname[1024];
        -:  247:void abort_gzip(void);
        -:  248:int copy(int in, int out);
        -:  249:ulg updcrc(uch *s, unsigned int n);
        -:  250:void clear_bufs(void);
        -:  251:void flush_outbuf(void);
        -:  252:char *strlwr(char *s);
        -:  253:char *basename(char *fname);
        -:  254:char *add_envopt(int *argcp, char ***argvp, char *env___0);
        -:  255:void write_error(void);
        -:  256:void display_ratio(long num, long den, FILE *file);
        -:  257:voidp xmalloc(unsigned int size);
        -:  258:ulg crc_32_tab[256];
        -:  259:
        -:  260:static ulg crc = (ulg)4294967295L;
    #####:  261:ulg updcrc(uch *s, unsigned int n) {
        -:  262:  register ulg c;
        -:  263:  uch *tmp;
        -:  264:
        -:  265:  {
        -:  266:
        -:  267:    {
    #####:  268:      c = crc;
    #####:  269:      if (n) {
        -:  270:
        -:  271:        while (1) {
        -:  272:          ;
    #####:  273:          tmp = s;
    #####:  274:          s++;
    #####:  275:          c = crc_32_tab[((int)c ^ (int)*tmp) & 255] ^ (c >> 8);
    #####:  276:          n--;
    #####:  277:          if (!n) {
    #####:  278:            goto while_break;
        -:  279:          }
        -:  280:        }
    #####:  281:      while_break: /* CIL Label */;
        -:  282:      }
        -:  283:    }
    #####:  284:    crc = c;
    #####:  285:    return (c ^ 4294967295UL);
        -:  286:  }
        -:  287:}
        -:  288:
    #####:  289:int fill_inbuf(int eof_ok) {
        -:  290:  int len;
        -:  291:
        -:  292:  {
    #####:  293:    { insize = 0U; }
        -:  294:    {
        -:  295:      {
        -:  296:        ;
        -:  297:        {
    #####:  298:          len = (int)read(ifd, (void *)((char *)(inbuf) + insize),
    #####:  299:                          (size_t)(32768U - insize));
        -:  300:        }
        -:  301:
    #####:  302:        insize += (unsigned int)len;
        -:  303:      };
        -:  304:    }
        -:  305:
    #####:  306:    inptr = 1U;
    #####:  307:    return ((int)inbuf[0]);
        -:  308:  }
        -:  309:}
    #####:  310:void flush_outbuf(void) {
        -:  311:
    #####:  312:  write_buf(ofd, (voidp)((char *)(outbuf)), outcnt);
        -:  313:
    #####:  314:  outcnt = 0U;
    #####:  315:}
    #####:  316:void flush_window(void) { write_buf(ofd, (voidp)((char *)(window)), outcnt); }
    #####:  317:void write_buf(int fd, voidp buf, unsigned int cnt) {
        -:  318:  unsigned int n;
        -:  319:
        -:  320:  {
        -:  321:
        -:  322:    {
        -:  323:      ;
    #####:  324:      { n = (unsigned int)write(fd, (void const *)buf, (size_t)cnt); }
        -:  325:
    #####:  326:      { write_error(); }
        -:  327:    };
        -:  328:  }
    #####:  329:}
        -:  330:
        -:  331:
    #####:  332:char *basename(char *fname) {
        -:  333:  char *p;
        -:  334:
        -:  335:  {
    #####:  336:    { p = strrchr((char const *)fname, '/'); }
    #####:  337:    if ((unsigned long)p != (unsigned long)((void *)0)) {
    #####:  338:      fname = p + 1;
        -:  339:    }
    #####:  340:    return (fname);
        -:  341:  }
        -:  342:}
        -:  343:/*
        -:  344:char *basename(char *fname) {
        -:  345:  char *p;
        -:  346:
        -:  347:  {
        -:  348:    { p = strrchr((char const *)fname, '/'); }
        -:  349:    { fname = p + 1; }
        -:  350:    return (fname);
        -:  351:  }
        -:  352:}
        -:  353:*/
        -:  354:
        -:  355:
        -:  356:
    #####:  357:void error(char *m) {
        -:  358:
    #####:  359:  fprintf((FILE * /* __restrict  */) stderr,
        -:  360:          (char const * /* __restrict  */) "\n%s: %s: %s\n", progname, ifname,
        -:  361:          m);
    #####:  362:}
        -:  363:
    #####:  364:void write_error(void) { perror((char const *)(ofname)); }
        -:  365:
        -:  366:ulg crc_32_tab[256] = {
        -:  367:    (ulg)0L,          (ulg)1996959894L, (ulg)3993919788L, (ulg)2567524794L,
        -:  368:    (ulg)124634137L,  (ulg)1886057615L, (ulg)3915621685L, (ulg)2657392035L,
        -:  369:    (ulg)249268274L,  (ulg)2044508324L, (ulg)3772115230L, (ulg)2547177864L,
        -:  370:    (ulg)162941995L,  (ulg)2125561021L, (ulg)3887607047L, (ulg)2428444049L,
        -:  371:    (ulg)498536548L,  (ulg)1789927666L, (ulg)4089016648L, (ulg)2227061214L,
        -:  372:    (ulg)450548861L,  (ulg)1843258603L, (ulg)4107580753L, (ulg)2211677639L,
        -:  373:    (ulg)325883990L,  (ulg)1684777152L, (ulg)4251122042L, (ulg)2321926636L,
        -:  374:    (ulg)335633487L,  (ulg)1661365465L, (ulg)4195302755L, (ulg)2366115317L,
        -:  375:    (ulg)997073096L,  (ulg)1281953886L, (ulg)3579855332L, (ulg)2724688242L,
        -:  376:    (ulg)1006888145L, (ulg)1258607687L, (ulg)3524101629L, (ulg)2768942443L,
        -:  377:    (ulg)901097722L,  (ulg)1119000684L, (ulg)3686517206L, (ulg)2898065728L,
        -:  378:    (ulg)853044451L,  (ulg)1172266101L, (ulg)3705015759L, (ulg)2882616665L,
        -:  379:    (ulg)651767980L,  (ulg)1373503546L, (ulg)3369554304L, (ulg)3218104598L,
        -:  380:    (ulg)565507253L,  (ulg)1454621731L, (ulg)3485111705L, (ulg)3099436303L,
        -:  381:    (ulg)671266974L,  (ulg)1594198024L, (ulg)3322730930L, (ulg)2970347812L,
        -:  382:    (ulg)795835527L,  (ulg)1483230225L, (ulg)3244367275L, (ulg)3060149565L,
        -:  383:    (ulg)1994146192L, (ulg)31158534L,   (ulg)2563907772L, (ulg)4023717930L,
        -:  384:    (ulg)1907459465L, (ulg)112637215L,  (ulg)2680153253L, (ulg)3904427059L,
        -:  385:    (ulg)2013776290L, (ulg)251722036L,  (ulg)2517215374L, (ulg)3775830040L,
        -:  386:    (ulg)2137656763L, (ulg)141376813L,  (ulg)2439277719L, (ulg)3865271297L,
        -:  387:    (ulg)1802195444L, (ulg)476864866L,  (ulg)2238001368L, (ulg)4066508878L,
        -:  388:    (ulg)1812370925L, (ulg)453092731L,  (ulg)2181625025L, (ulg)4111451223L,
        -:  389:    (ulg)1706088902L, (ulg)314042704L,  (ulg)2344532202L, (ulg)4240017532L,
        -:  390:    (ulg)1658658271L, (ulg)366619977L,  (ulg)2362670323L, (ulg)4224994405L,
        -:  391:    (ulg)1303535960L, (ulg)984961486L,  (ulg)2747007092L, (ulg)3569037538L,
        -:  392:    (ulg)1256170817L, (ulg)1037604311L, (ulg)2765210733L, (ulg)3554079995L,
        -:  393:    (ulg)1131014506L, (ulg)879679996L,  (ulg)2909243462L, (ulg)3663771856L,
        -:  394:    (ulg)1141124467L, (ulg)855842277L,  (ulg)2852801631L, (ulg)3708648649L,
        -:  395:    (ulg)1342533948L, (ulg)654459306L,  (ulg)3188396048L, (ulg)3373015174L,
        -:  396:    (ulg)1466479909L, (ulg)544179635L,  (ulg)3110523913L, (ulg)3462522015L,
        -:  397:    (ulg)1591671054L, (ulg)702138776L,  (ulg)2966460450L, (ulg)3352799412L,
        -:  398:    (ulg)1504918807L, (ulg)783551873L,  (ulg)3082640443L, (ulg)3233442989L,
        -:  399:    (ulg)3988292384L, (ulg)2596254646L, (ulg)62317068L,   (ulg)1957810842L,
        -:  400:    (ulg)3939845945L, (ulg)2647816111L, (ulg)81470997L,   (ulg)1943803523L,
        -:  401:    (ulg)3814918930L, (ulg)2489596804L, (ulg)225274430L,  (ulg)2053790376L,
        -:  402:    (ulg)3826175755L, (ulg)2466906013L, (ulg)167816743L,  (ulg)2097651377L,
        -:  403:    (ulg)4027552580L, (ulg)2265490386L, (ulg)503444072L,  (ulg)1762050814L,
        -:  404:    (ulg)4150417245L, (ulg)2154129355L, (ulg)426522225L,  (ulg)1852507879L,
        -:  405:    (ulg)4275313526L, (ulg)2312317920L, (ulg)282753626L,  (ulg)1742555852L,
        -:  406:    (ulg)4189708143L, (ulg)2394877945L, (ulg)397917763L,  (ulg)1622183637L,
        -:  407:    (ulg)3604390888L, (ulg)2714866558L, (ulg)953729732L,  (ulg)1340076626L,
        -:  408:    (ulg)3518719985L, (ulg)2797360999L, (ulg)1068828381L, (ulg)1219638859L,
        -:  409:    (ulg)3624741850L, (ulg)2936675148L, (ulg)906185462L,  (ulg)1090812512L,
        -:  410:    (ulg)3747672003L, (ulg)2825379669L, (ulg)829329135L,  (ulg)1181335161L,
        -:  411:    (ulg)3412177804L, (ulg)3160834842L, (ulg)628085408L,  (ulg)1382605366L,
        -:  412:    (ulg)3423369109L, (ulg)3138078467L, (ulg)570562233L,  (ulg)1426400815L,
        -:  413:    (ulg)3317316542L, (ulg)2998733608L, (ulg)733239954L,  (ulg)1555261956L,
        -:  414:    (ulg)3268935591L, (ulg)3050360625L, (ulg)752459403L,  (ulg)1541320221L,
        -:  415:    (ulg)2607071920L, (ulg)3965973030L, (ulg)1969922972L, (ulg)40735498L,
        -:  416:    (ulg)2617837225L, (ulg)3943577151L, (ulg)1913087877L, (ulg)83908371L,
        -:  417:    (ulg)2512341634L, (ulg)3803740692L, (ulg)2075208622L, (ulg)213261112L,
        -:  418:    (ulg)2463272603L, (ulg)3855990285L, (ulg)2094854071L, (ulg)198958881L,
        -:  419:    (ulg)2262029012L, (ulg)4057260610L, (ulg)1759359992L, (ulg)534414190L,
        -:  420:    (ulg)2176718541L, (ulg)4139329115L, (ulg)1873836001L, (ulg)414664567L,
        -:  421:    (ulg)2282248934L, (ulg)4279200368L, (ulg)1711684554L, (ulg)285281116L,
        -:  422:    (ulg)2405801727L, (ulg)4167216745L, (ulg)1634467795L, (ulg)376229701L,
        -:  423:    (ulg)2685067896L, (ulg)3608007406L, (ulg)1308918612L, (ulg)956543938L,
        -:  424:    (ulg)2808555105L, (ulg)3495958263L, (ulg)1231636301L, (ulg)1047427035L,
        -:  425:    (ulg)2932959818L, (ulg)3654703836L, (ulg)1088359270L, (ulg)936918000L,
        -:  426:    (ulg)2847714899L, (ulg)3736837829L, (ulg)1202900863L, (ulg)817233897L,
        -:  427:    (ulg)3183342108L, (ulg)3401237130L, (ulg)1404277552L, (ulg)615818150L,
        -:  428:    (ulg)3134207493L, (ulg)3453421203L, (ulg)1423857449L, (ulg)601450431L,
        -:  429:    (ulg)3009837614L, (ulg)3294710456L, (ulg)1567103746L, (ulg)711928724L,
        -:  430:    (ulg)3020668471L, (ulg)3272380065L, (ulg)1510334235L, (ulg)755167117L};
        -:  431:int inflate(void);
        -:  432:int huft_build(unsigned int *b, unsigned int n, unsigned int s, ush *d, ush *e,
        -:  433:               struct huft **t, int *m);
        -:  434:int huft_free(struct huft *t);
        -:  435:int inflate_codes(struct huft *tl, struct huft *td, int bl, int bd);
        -:  436:int inflate_stored(void);
        -:  437:int inflate_fixed(void);
        -:  438:int inflate_dynamic(void);
        -:  439:int inflate_block(int *e);
        -:  440:static unsigned int border[19] = {16U, 17U, 18U, 0U, 8U,  7U, 9U,  6U, 10U, 5U,
        -:  441:                                  11U, 4U,  12U, 3U, 13U, 2U, 14U, 1U, 15U};
        -:  442:static ush cplens[31] = {
        -:  443:    (ush)3,   (ush)4,  (ush)5,   (ush)6,   (ush)7,   (ush)8,   (ush)9,
        -:  444:    (ush)10,  (ush)11, (ush)13,  (ush)15,  (ush)17,  (ush)19,  (ush)23,
        -:  445:    (ush)27,  (ush)31, (ush)35,  (ush)43,  (ush)51,  (ush)59,  (ush)67,
        -:  446:    (ush)83,  (ush)99, (ush)115, (ush)131, (ush)163, (ush)195, (ush)227,
        -:  447:    (ush)258, (ush)0,  (ush)0};
        -:  448:static ush cplext[31] = {
        -:  449:    (ush)0, (ush)0, (ush)0, (ush)0, (ush)0, (ush)0,  (ush)0, (ush)0,
        -:  450:    (ush)1, (ush)1, (ush)1, (ush)1, (ush)2, (ush)2,  (ush)2, (ush)2,
        -:  451:    (ush)3, (ush)3, (ush)3, (ush)3, (ush)4, (ush)4,  (ush)4, (ush)4,
        -:  452:    (ush)5, (ush)5, (ush)5, (ush)5, (ush)0, (ush)99, (ush)99};
        -:  453:static ush cpdist[30] = {
        -:  454:    (ush)1,    (ush)2,    (ush)3,    (ush)4,     (ush)5,     (ush)7,
        -:  455:    (ush)9,    (ush)13,   (ush)17,   (ush)25,    (ush)33,    (ush)49,
        -:  456:    (ush)65,   (ush)97,   (ush)129,  (ush)193,   (ush)257,   (ush)385,
        -:  457:    (ush)513,  (ush)769,  (ush)1025, (ush)1537,  (ush)2049,  (ush)3073,
        -:  458:    (ush)4097, (ush)6145, (ush)8193, (ush)12289, (ush)16385, (ush)24577};
        -:  459:static ush cpdext[30] = {(ush)0,  (ush)0,  (ush)0,  (ush)0,  (ush)1,  (ush)1,
        -:  460:                         (ush)2,  (ush)2,  (ush)3,  (ush)3,  (ush)4,  (ush)4,
        -:  461:                         (ush)5,  (ush)5,  (ush)6,  (ush)6,  (ush)7,  (ush)7,
        -:  462:                         (ush)8,  (ush)8,  (ush)9,  (ush)9,  (ush)10, (ush)10,
        -:  463:                         (ush)11, (ush)11, (ush)12, (ush)12, (ush)13, (ush)13};
        -:  464:ulg bb;
        -:  465:unsigned int bk;
        -:  466:ush mask_bits[17] = {(ush)0,     (ush)1,    (ush)3,    (ush)7,    (ush)15,
        -:  467:                     (ush)31,    (ush)63,   (ush)127,  (ush)255,  (ush)511,
        -:  468:                     (ush)1023,  (ush)2047, (ush)4095, (ush)8191, (ush)16383,
        -:  469:                     (ush)32767, (ush)65535};
        -:  470:
        -:  471:int dbits = 6;
        -:  472:
    #####:  473:int huft_build(unsigned int *b, unsigned int n, unsigned int s, ush *d, ush *e,
        -:  474:               struct huft **t, int *m) {
        -:  475:  unsigned int a;
        -:  476:  unsigned int c[17];
        -:  477:  unsigned int f;
        -:  478:  int g;
        -:  479:  int h;
        -:  480:  register unsigned int i___0;
        -:  481:  register unsigned int j___0;
        -:  482:  register int k;
        -:  483:  int l;
        -:  484:  register unsigned int *p;
        -:  485:  register struct huft *q;
        -:  486:  struct huft r;
        -:  487:  struct huft *u[16];
        -:  488:  unsigned int v[288];
        -:  489:  register int w;
        -:  490:  unsigned int x[17];
        -:  491:  unsigned int *xp;
        -:  492:
        -:  493:  unsigned int z;
        -:  494:  unsigned int *tmp;
        -:  495:  unsigned int *tmp___0;
        -:  496:  unsigned int tmp___1;
        -:  497:  unsigned int *tmp___2;
        -:  498:  int tmp___4;
        -:  499:  unsigned int *tmp___5;
        -:  500:  unsigned int tmp___6;
        -:  501:  int tmp___7;
        -:  502:
        -:  503:  {
        -:  504:    {
    #####:  505:      memset((voidp)(c), 0, sizeof(c));
    #####:  506:      p = b;
    #####:  507:      i___0 = n;
        -:  508:    }
        -:  509:    {
        -:  510:      while (1) {
        -:  511:        ;
    #####:  512:        (c[*p])++;
    #####:  513:        p++;
    #####:  514:        i___0--;
    #####:  515:        if (!i___0) {
    #####:  516:          goto while_break;
        -:  517:        }
        -:  518:      }
    #####:  519:    while_break: /* CIL Label */;
        -:  520:    }
        -:  521:
    #####:  522:    l = *m;
    #####:  523:    j___0 = 1U;
        -:  524:
    #####:  525:    k = (int)j___0;
        -:  526:
    #####:  527:    i___0 = 16U;
        -:  528:
    #####:  529:    g = (int)i___0;
        -:  530:
    #####:  531:    j___0 = 0U;
        -:  532:
    #####:  533:    p = c + 1;
    #####:  534:    xp = x + 2;
        -:  535:    {
        -:  536:      while (1) {
        -:  537:        ;
    #####:  538:        i___0--;
    #####:  539:        if (!i___0) {
    #####:  540:          goto while_break___3;
        -:  541:        }
    #####:  542:        tmp = xp;
    #####:  543:        xp++;
    #####:  544:        tmp___0 = p;
    #####:  545:        p++;
    #####:  546:        j___0 += *tmp___0;
    #####:  547:        *tmp = j___0;
        -:  548:      }
    #####:  549:    while_break___3: /* CIL Label */;
        -:  550:    }
    #####:  551:    p = b;
        -:  552:
        -:  553:    {
        -:  554:      while (1) {
        -:  555:        ;
    #####:  556:        tmp___2 = p;
    #####:  557:        p++;
    #####:  558:        j___0 = *tmp___2;
    #####:  559:        if (j___0 != 0U) {
    #####:  560:          tmp___1 = x[j___0];
    #####:  561:          (x[j___0])++;
    #####:  562:          v[tmp___1] = i___0;
        -:  563:        }
    #####:  564:        i___0++;
    #####:  565:        if (!(i___0 < n)) {
    #####:  566:          goto while_break___4;
        -:  567:        }
        -:  568:      }
    #####:  569:    while_break___4: /* CIL Label */;
        -:  570:    }
    #####:  571:    i___0 = 0U;
    #####:  572:    x[0] = i___0;
    #####:  573:    p = v;
    #####:  574:    h = -1;
    #####:  575:    w = -l;
        -:  576:
        -:  577:    {
        -:  578:      while (1) {
        -:  579:        ;
    #####:  580:        if (!(k <= g)) {
    #####:  581:          goto while_break___5;
        -:  582:        }
    #####:  583:        a = c[k];
        -:  584:        {
        -:  585:          while (1) {
        -:  586:            ;
    #####:  587:            tmp___6 = a;
    #####:  588:            a--;
    #####:  589:            if (!tmp___6) {
    #####:  590:              goto while_break___6;
        -:  591:            }
        -:  592:            {
        -:  593:              {
        -:  594:                ;
    #####:  595:                if (!(k > w + l)) {
    #####:  596:                  goto while_break___7;
        -:  597:                }
    #####:  598:                h++;
    #####:  599:                w += l;
        -:  600:
    #####:  601:                { z = (unsigned int)l; }
        -:  602:
    #####:  603:                j___0 = (unsigned int)(k - w);
        -:  604:
        -:  605:                {
        -:  606:
        -:  607:                  while (1) {
        -:  608:                    ;
    #####:  609:                    j___0++;
    #####:  610:                    if (!(j___0 < z)) {
    #####:  611:                      goto while_break___8;
        -:  612:                    }
        -:  613:                  }
    #####:  614:                while_break___8: /* CIL Label */;
        -:  615:                }
        -:  616:                {
    #####:  617:                  z = (unsigned int)(1 << j___0);
    #####:  618:                  q = (struct huft *)malloc((unsigned long)(z + 1U) *
        -:  619:                                            sizeof(struct huft));
        -:  620:                }
    #####:  621:                if ((unsigned long)q ==
        -:  622:                    (unsigned long)((struct huft *)((void *)0))) {
        -:  623:
    #####:  624:                  return (3);
        -:  625:                }
        -:  626:
    #####:  627:                *t = q + 1;
    #####:  628:                t = &q->v.t;
        -:  629:
    #####:  630:                q++;
    #####:  631:                u[h] = q;
    #####:  632:                if (h) {
    #####:  633:                  x[h] = i___0;
    #####:  634:                  r.b = (uch)l;
    #####:  635:                  r.e = (uch)(16U + j___0);
    #####:  636:                  r.v.t = q;
    #####:  637:                  j___0 = i___0 >> (w - l);
    #####:  638:                  *(u[h - 1] + j___0) = r;
        -:  639:                }
        -:  640:              }
    #####:  641:            while_break___7: /* CIL Label */;
        -:  642:            }
    #####:  643:            r.b = (uch)(k - w);
        -:  644:
        -:  645:            {
    #####:  646:              if (*p < s) {
    #####:  647:                if (*p < 256U) {
    #####:  648:                  tmp___4 = 16;
        -:  649:                } else {
    #####:  650:                  tmp___4 = 15;
        -:  651:                }
    #####:  652:                r.e = (uch)tmp___4;
    #####:  653:                r.v.n = (ush)*p;
    #####:  654:                p++;
        -:  655:              } else {
    #####:  656:                r.e = (uch) * (e + (*p - s));
    #####:  657:                tmp___5 = p;
    #####:  658:                p++;
    #####:  659:                r.v.n = *(d + (*tmp___5 - s));
        -:  660:              }
        -:  661:            }
    #####:  662:            f = (unsigned int)(1 << (k - w));
    #####:  663:            j___0 = i___0 >> w;
        -:  664:            {
        -:  665:              while (1) {
        -:  666:                ;
    #####:  667:                if (!(j___0 < z)) {
    #####:  668:                  goto while_break___9;
        -:  669:                }
    #####:  670:                *(q + j___0) = r;
    #####:  671:                j___0 += f;
        -:  672:              }
    #####:  673:            while_break___9: /* CIL Label */;
        -:  674:            }
    #####:  675:            j___0 = (unsigned int)(1 << (k - 1));
        -:  676:            {
        -:  677:              while (1) {
        -:  678:                ;
    #####:  679:                if (!(i___0 & j___0)) {
    #####:  680:                  goto while_break___10;
        -:  681:                }
    #####:  682:                i___0 ^= j___0;
    #####:  683:                j___0 >>= 1;
        -:  684:              }
    #####:  685:            while_break___10: /* CIL Label */;
        -:  686:            }
    #####:  687:            i___0 ^= j___0;
        -:  688:            {
        -:  689:              {
        -:  690:                ;
    #####:  691:                if (!((i___0 & (unsigned int)((1 << w) - 1)) != x[h])) {
    #####:  692:                  goto while_break___11;
        -:  693:                }
    #####:  694:                h--;
    #####:  695:                w -= l;
        -:  696:              }
    #####:  697:            while_break___11: /* CIL Label */;
        -:  698:            }
        -:  699:          }
    #####:  700:        while_break___6: /* CIL Label */;
        -:  701:        }
    #####:  702:        k++;
        -:  703:      }
    #####:  704:    while_break___5: /* CIL Label */;
        -:  705:    }
        -:  706:
    #####:  707:    { tmp___7 = 0; }
    #####:  708:    return (tmp___7);
        -:  709:  }
        -:  710:}
        -:  711:
    #####:  712:int inflate_codes(struct huft *tl, struct huft *td, int bl, int bd) {
        -:  713:  register unsigned int e;
        -:  714:  unsigned int n;
        -:  715:  unsigned int d;
        -:  716:  unsigned int w;
        -:  717:  struct huft *t;
        -:  718:  unsigned int ml;
        -:  719:  unsigned int md;
        -:  720:  register ulg b;
        -:  721:  register unsigned int k;
        -:  722:  unsigned int tmp;
        -:  723:
        -:  724:  int tmp___1;
        -:  725:  unsigned int tmp___2;
        -:  726:
        -:  727:  int tmp___4;
        -:  728:  unsigned int tmp___5;
        -:  729:  unsigned int tmp___6;
        -:  730:  int tmp___7;
        -:  731:  int tmp___8;
        -:  732:  unsigned int tmp___9;
        -:  733:
        -:  734:  int tmp___11;
        -:  735:
        -:  736:  unsigned int tmp___15;
        -:  737:
        -:  738:  int tmp___17;
        -:  739:  unsigned int tmp___19;
        -:  740:  unsigned int tmp___20;
        -:  741:  unsigned int tmp___21;
        -:  742:
        -:  743:  {
    #####:  744:    b = bb;
    #####:  745:    k = bk;
    #####:  746:    w = outcnt;
    #####:  747:    ml = (unsigned int)mask_bits[bl];
    #####:  748:    md = (unsigned int)mask_bits[bd];
        -:  749:    {
        -:  750:      while (1) {
        -:  751:        ;
        -:  752:        {
        -:  753:          {
        -:  754:            ;
    #####:  755:            if (!(k < (unsigned int)bl)) {
    #####:  756:              goto while_break___0;
        -:  757:            }
        -:  758:            {
    #####:  759:              tmp = inptr;
    #####:  760:              inptr++;
    #####:  761:              tmp___1 = (int)inbuf[tmp];
        -:  762:            }
        -:  763:
    #####:  764:            b |= (ulg)((uch)tmp___1) << k;
    #####:  765:            k += 8U;
        -:  766:          }
    #####:  767:        while_break___0: /* CIL Label */;
        -:  768:        }
    #####:  769:        t = tl + ((unsigned int)b & ml);
    #####:  770:        e = (unsigned int)t->e;
    #####:  771:        if (e > 16U) {
        -:  772:
        -:  773:          {
        -:  774:            ;
        -:  775:
    #####:  776:            b >>= (int)t->b;
    #####:  777:            k -= (unsigned int)t->b;
    #####:  778:            e -= 16U;
        -:  779:            {
        -:  780:              {
        -:  781:                ;
        -:  782:
        -:  783:                {
    #####:  784:                  tmp___2 = inptr;
    #####:  785:                  inptr++;
    #####:  786:                  tmp___4 = (int)inbuf[tmp___2];
        -:  787:                }
        -:  788:
    #####:  789:                b |= (ulg)((uch)tmp___4) << k;
    #####:  790:                k += 8U;
        -:  791:              };
        -:  792:            }
    #####:  793:            t = t->v.t + ((unsigned int)b & (unsigned int)mask_bits[e]);
    #####:  794:            e = (unsigned int)t->e;
        -:  795:          };
        -:  796:        }
    #####:  797:        b >>= (int)t->b;
    #####:  798:        k -= (unsigned int)t->b;
    #####:  799:        if (e == 16U) {
    #####:  800:          tmp___5 = w;
    #####:  801:          w++;
    #####:  802:          window[tmp___5] = (uch)t->v.n;
    #####:  803:          if (w == 32768U) {
        -:  804:
    #####:  805:            flush_window();
    #####:  806:            w = 0U;
        -:  807:          }
        -:  808:        } else {
    #####:  809:          if (e == 15U) {
    #####:  810:            goto while_break;
        -:  811:          }
        -:  812:          {
        -:  813:            {
        -:  814:              ;
        -:  815:
    #####:  816:              if (inptr < insize) {
    #####:  817:                tmp___6 = inptr;
    #####:  818:                inptr++;
    #####:  819:                tmp___8 = (int)inbuf[tmp___6];
        -:  820:              } else {
        -:  821:
    #####:  822:                tmp___7 = fill_inbuf(0);
    #####:  823:                tmp___8 = tmp___7;
        -:  824:              }
    #####:  825:              b |= (ulg)((uch)tmp___8) << k;
    #####:  826:              k += 8U;
        -:  827:            };
        -:  828:          }
    #####:  829:          n = (unsigned int)t->v.n +
    #####:  830:              ((unsigned int)b & (unsigned int)mask_bits[e]);
    #####:  831:          b >>= e;
    #####:  832:          k -= e;
        -:  833:          {
        -:  834:            {
        -:  835:              ;
        -:  836:
        -:  837:              {
    #####:  838:                tmp___9 = inptr;
    #####:  839:                inptr++;
    #####:  840:                tmp___11 = (int)inbuf[tmp___9];
        -:  841:              }
        -:  842:
    #####:  843:              b |= (ulg)((uch)tmp___11) << k;
    #####:  844:              k += 8U;
        -:  845:            };
        -:  846:          }
    #####:  847:          t = td + ((unsigned int)b & md);
    #####:  848:          e = (unsigned int)t->e;
    #####:  849:          if (e > 16U) {
        -:  850:
        -:  851:            while (1) {
        -:  852:              ;
        -:  853:
    #####:  854:              b >>= (int)t->b;
    #####:  855:              k -= (unsigned int)t->b;
    #####:  856:              e -= 16U;
        -:  857:
    #####:  858:              t = t->v.t + ((unsigned int)b & (unsigned int)mask_bits[e]);
    #####:  859:              e = (unsigned int)t->e;
    #####:  860:              if (!(e > 16U)) {
    #####:  861:                goto while_break___5;
        -:  862:              }
        -:  863:            }
    #####:  864:          while_break___5: /* CIL Label */;
        -:  865:          }
    #####:  866:          b >>= (int)t->b;
    #####:  867:          k -= (unsigned int)t->b;
        -:  868:          {
        -:  869:            {
        -:  870:              ;
    #####:  871:              if (!(k < e)) {
    #####:  872:                goto while_break___7;
        -:  873:              }
        -:  874:              {
    #####:  875:                tmp___15 = inptr;
    #####:  876:                inptr++;
    #####:  877:                tmp___17 = (int)inbuf[tmp___15];
        -:  878:              }
        -:  879:
    #####:  880:              b |= (ulg)((uch)tmp___17) << k;
    #####:  881:              k += 8U;
        -:  882:            }
    #####:  883:          while_break___7: /* CIL Label */;
        -:  884:          }
    #####:  885:          d = (w - (unsigned int)t->v.n) -
    #####:  886:              ((unsigned int)b & (unsigned int)mask_bits[e]);
    #####:  887:          b >>= e;
    #####:  888:          k -= e;
        -:  889:          {
        -:  890:            while (1) {
        -:  891:              ;
    #####:  892:              d &= 32767U;
    #####:  893:              if (d > w) {
    #####:  894:                tmp___19 = d;
        -:  895:              } else {
    #####:  896:                tmp___19 = w;
        -:  897:              }
    #####:  898:              e = 32768U - tmp___19;
    #####:  899:              if (e > n) {
    #####:  900:                e = n;
        -:  901:              } else {
        -:  902:              }
    #####:  903:              n -= e;
        -:  904:
        -:  905:              {
        -:  906:
        -:  907:                while (1) {
        -:  908:                  ;
    #####:  909:                  tmp___20 = w;
    #####:  910:                  w++;
    #####:  911:                  tmp___21 = d;
    #####:  912:                  d++;
    #####:  913:                  window[tmp___20] = window[tmp___21];
    #####:  914:                  e--;
    #####:  915:                  if (!e) {
    #####:  916:                    goto while_break___9;
        -:  917:                  }
        -:  918:                }
    #####:  919:              while_break___9: /* CIL Label */;
        -:  920:              }
    #####:  921:              if (w == 32768U) {
        -:  922:
    #####:  923:                outcnt = w;
    #####:  924:                flush_window();
    #####:  925:                w = 0U;
        -:  926:              }
    #####:  927:              if (!n) {
    #####:  928:                goto while_break___8;
        -:  929:              }
        -:  930:            }
    #####:  931:          while_break___8: /* CIL Label */;
        -:  932:          }
        -:  933:        }
        -:  934:      }
    #####:  935:    while_break: /* CIL Label */;
        -:  936:    }
    #####:  937:    outcnt = w;
    #####:  938:    bb = b;
    #####:  939:    bk = k;
    #####:  940:    return (0);
        -:  941:  }
        -:  942:}
        -:  943:
    #####:  944:int inflate_dynamic(void) {
        -:  945:  int i___0;
        -:  946:  unsigned int j___0;
        -:  947:  unsigned int l;
        -:  948:  unsigned int m;
        -:  949:  unsigned int n;
        -:  950:  struct huft *tl;
        -:  951:  struct huft *td;
        -:  952:  int bl;
        -:  953:  int bd;
        -:  954:  unsigned int nb;
        -:  955:  unsigned int nl;
        -:  956:  unsigned int nd;
        -:  957:  unsigned int ll[316];
        -:  958:  register ulg b;
        -:  959:  register unsigned int k;
        -:  960:  unsigned int tmp;
        -:  961:
        -:  962:  int tmp___1;
        -:  963:
        -:  964:  unsigned int tmp___5;
        -:  965:
        -:  966:  int tmp___7;
        -:  967:  unsigned int tmp___8;
        -:  968:
        -:  969:  int tmp___10;
        -:  970:  unsigned int tmp___11;
        -:  971:
        -:  972:  int tmp___13;
        -:  973:  int tmp___14;
        -:  974:
        -:  975:  int tmp___18;
        -:  976:  unsigned int tmp___19;
        -:  977:
        -:  978:  int tmp___30;
        -:  979:
        -:  980:  {
    #####:  981:    b = bb;
    #####:  982:    k = bk;
        -:  983:    {
        -:  984:      {
        -:  985:        ;
        -:  986:
        -:  987:        {
    #####:  988:          tmp = inptr;
    #####:  989:          inptr++;
    #####:  990:          tmp___1 = (int)inbuf[tmp];
        -:  991:        }
        -:  992:
    #####:  993:        b |= (ulg)((uch)tmp___1) << k;
    #####:  994:        k += 8U;
        -:  995:      };
        -:  996:    }
    #####:  997:    nl = 257U + ((unsigned int)b & 31U);
    #####:  998:    b >>= 5;
    #####:  999:    k -= 5U;
        -: 1000:
    #####: 1001:    nd = 1U + ((unsigned int)b & 31U);
    #####: 1002:    b >>= 5;
    #####: 1003:    k -= 5U;
        -: 1004:    {
        -: 1005:      {
        -: 1006:        ;
        -: 1007:
        -: 1008:        {
    #####: 1009:          tmp___5 = inptr;
    #####: 1010:          inptr++;
    #####: 1011:          tmp___7 = (int)inbuf[tmp___5];
        -: 1012:        }
        -: 1013:
    #####: 1014:        b |= (ulg)((uch)tmp___7) << k;
    #####: 1015:        k += 8U;
        -: 1016:      };
        -: 1017:    }
    #####: 1018:    nb = 4U + ((unsigned int)b & 15U);
    #####: 1019:    b >>= 4;
    #####: 1020:    k -= 4U;
        -: 1021:
    #####: 1022:    j___0 = 0U;
        -: 1023:    {
        -: 1024:      while (1) {
        -: 1025:        ;
    #####: 1026:        if (!(j___0 < nb)) {
    #####: 1027:          goto while_break___2;
        -: 1028:        }
        -: 1029:        {
        -: 1030:          {
        -: 1031:            ;
    #####: 1032:            if (!(k < 3U)) {
    #####: 1033:              goto while_break___3;
        -: 1034:            }
        -: 1035:            {
    #####: 1036:              tmp___8 = inptr;
    #####: 1037:              inptr++;
    #####: 1038:              tmp___10 = (int)inbuf[tmp___8];
        -: 1039:            }
        -: 1040:
    #####: 1041:            b |= (ulg)((uch)tmp___10) << k;
    #####: 1042:            k += 8U;
        -: 1043:          }
    #####: 1044:        while_break___3: /* CIL Label */;
        -: 1045:        }
    #####: 1046:        ll[border[j___0]] = (unsigned int)b & 7U;
    #####: 1047:        b >>= 3;
    #####: 1048:        k -= 3U;
    #####: 1049:        j___0++;
        -: 1050:      }
    #####: 1051:    while_break___2: /* CIL Label */;
        -: 1052:    }
        -: 1053:    {
        -: 1054:      while (1) {
        -: 1055:        ;
    #####: 1056:        if (!(j___0 < 19U)) {
    #####: 1057:          goto while_break___4;
        -: 1058:        }
    #####: 1059:        ll[border[j___0]] = 0U;
    #####: 1060:        j___0++;
        -: 1061:      }
    #####: 1062:    while_break___4: /* CIL Label */;
        -: 1063:    }
        -: 1064:    {
    #####: 1065:      bl = 7;
    #####: 1066:      i___0 = huft_build(ll, 19U, 19U, (ush *)((void *)0), (ush *)((void *)0),
        -: 1067:                         &tl, &bl);
        -: 1068:    }
    #####: 1069:    if (i___0 != 0) {
        -: 1070:
    #####: 1071:      return (i___0);
        -: 1072:    }
    #####: 1073:    n = nl + nd;
    #####: 1074:    m = (unsigned int)mask_bits[bl];
        -: 1075:
        -: 1076:    {
        -: 1077:      while (1) {
        -: 1078:        ;
    #####: 1079:        if (!((unsigned int)i___0 < n)) {
    #####: 1080:          goto while_break___5;
        -: 1081:        }
        -: 1082:        {
        -: 1083:          {
        -: 1084:            ;
    #####: 1085:            if (!(k < (unsigned int)bl)) {
    #####: 1086:              goto while_break___6;
        -: 1087:            }
        -: 1088:            {
    #####: 1089:              tmp___11 = inptr;
    #####: 1090:              inptr++;
    #####: 1091:              tmp___13 = (int)inbuf[tmp___11];
        -: 1092:            }
        -: 1093:
    #####: 1094:            b |= (ulg)((uch)tmp___13) << k;
    #####: 1095:            k += 8U;
        -: 1096:          }
    #####: 1097:        while_break___6: /* CIL Label */;
        -: 1098:        }
    #####: 1099:        td = tl + ((unsigned int)b & m);
    #####: 1100:        j___0 = (unsigned int)td->b;
    #####: 1101:        b >>= j___0;
    #####: 1102:        k -= j___0;
    #####: 1103:        j___0 = (unsigned int)td->v.n;
    #####: 1104:        if (j___0 < 16U) {
    #####: 1105:          tmp___14 = i___0;
    #####: 1106:          i___0++;
    #####: 1107:          l = j___0;
    #####: 1108:          ll[tmp___14] = l;
        -: 1109:        } else {
        -: 1110:
    #####: 1111:          j___0 = 3U + ((unsigned int)b & 3U);
    #####: 1112:          b >>= 2;
    #####: 1113:          k -= 2U;
        -: 1114:
        -: 1115:          {
        -: 1116:            while (1) {
        -: 1117:              ;
    #####: 1118:              tmp___19 = j___0;
    #####: 1119:              j___0--;
    #####: 1120:              if (!tmp___19) {
    #####: 1121:                goto while_break___8;
        -: 1122:              }
    #####: 1123:              tmp___18 = i___0;
    #####: 1124:              i___0++;
    #####: 1125:              ll[tmp___18] = l;
        -: 1126:            }
    #####: 1127:          while_break___8: /* CIL Label */;
        -: 1128:          }
        -: 1129:        }
        -: 1130:      }
    #####: 1131:    while_break___5: /* CIL Label */;
        -: 1132:    }
        -: 1133:    {
        -: 1134:
    #####: 1135:      bb = b;
    #####: 1136:      bk = k;
        -: 1137:
    #####: 1138:      i___0 = huft_build(ll, nl, 257U, cplens, cplext, &tl, &bl);
        -: 1139:    }
        -: 1140:
        -: 1141:    {
    #####: 1142:      bd = dbits;
    #####: 1143:      i___0 = huft_build(ll + nl, nd, 0U, cpdist, cpdext, &td, &bd);
        -: 1144:    }
        -: 1145:
    #####: 1146:    { tmp___30 = inflate_codes(tl, td, bl, bd); }
        -: 1147:
    #####: 1148:    return (0);
        -: 1149:  }
        -: 1150:}
    #####: 1151:int inflate_block(int *e) {
        -: 1152:
        -: 1153:  register ulg b;
        -: 1154:  register unsigned int k;
        -: 1155:  unsigned int tmp;
        -: 1156:
        -: 1157:  int tmp___1;
        -: 1158:
        -: 1159:  int tmp___5;
        -: 1160:
        -: 1161:  {
    #####: 1162:    b = bb;
    #####: 1163:    k = bk;
        -: 1164:    {
        -: 1165:      {
        -: 1166:        ;
        -: 1167:
        -: 1168:        {
    #####: 1169:          tmp = inptr;
    #####: 1170:          inptr++;
    #####: 1171:          tmp___1 = (int)inbuf[tmp];
        -: 1172:        }
        -: 1173:
    #####: 1174:        b |= (ulg)((uch)tmp___1) << k;
    #####: 1175:        k += 8U;
        -: 1176:      };
        -: 1177:    }
    #####: 1178:    *e = (int)b & 1;
    #####: 1179:    b >>= 1;
    #####: 1180:    k--;
        -: 1181:
    #####: 1182:    b >>= 2;
    #####: 1183:    k -= 2U;
    #####: 1184:    bb = b;
    #####: 1185:    bk = k;
        -: 1186:    {
    #####: 1187:      { tmp___5 = inflate_dynamic(); }
    #####: 1188:      return (tmp___5);
        -: 1189:    }
        -: 1190:  }
        -: 1191:}
    #####: 1192:int inflate(void) {
        -: 1193:  int e;
        -: 1194:  int r;
        -: 1195:
        -: 1196:  {
        -: 1197:
        -: 1198:    {
        -: 1199:      while (1) {
        -: 1200:        ;
    #####: 1201:        { r = inflate_block(&e); }
    #####: 1202:        if (r != 0) {
    #####: 1203:          return (r);
        -: 1204:        }
        -: 1205:
    #####: 1206:        if (!(!e)) {
    #####: 1207:          goto while_break;
        -: 1208:        }
        -: 1209:      }
    #####: 1210:    while_break: /* CIL Label */;
        -: 1211:    }
        -: 1212:
    #####: 1213:    { flush_window(); }
        -: 1214:  }
    #####: 1215:}
        -: 1216:int method;
        -: 1217:
        -: 1218:int unzip(int in, int out);
        -: 1219:int check_zipfile(int in);
        -: 1220:
    #####: 1221:int unzip(int in, int out) {
        -: 1222:
        -: 1223:  int tmp;
        -: 1224:
        -: 1225:  {
    #####: 1226:    { ofd = out; }
        -: 1227:
        -: 1228:    {
    #####: 1229:      { tmp = inflate(); }
    #####: 1230:      { error((char *)"out of memory"); }
        -: 1231:    }
        -: 1232:
    #####: 1233:    return (0);
        -: 1234:  }
        -: 1235:}
        -: 1236:int file_read(char *buf, unsigned int size);
        -: 1237:void bi_init(file_t zipfile);
        -: 1238:void send_bits(int value, int length);
        -: 1239:unsigned int bi_reverse(unsigned int code, int len);
        -: 1240:void bi_windup(void);
        -: 1241:void copy_block(char *buf, unsigned int len, int header);
        -: 1242:int (*read_buf)(char *buf, unsigned int size);
        -: 1243:
        -: 1244:static unsigned short bi_buf;
        -: 1245:static int bi_valid;
    #####: 1246:void bi_init(file_t zipfile) { read_buf = &file_read; }
    #####: 1247:void send_bits(int value, int length) {
        -: 1248:
        -: 1249:  unsigned int tmp___1;
        -: 1250:  unsigned int tmp___2;
        -: 1251:
        -: 1252:  {
    #####: 1253:    if (bi_valid > (int)(16UL * sizeof(char)) - length) {
    #####: 1254:      bi_buf = (unsigned short)((int)bi_buf | (value << bi_valid));
        -: 1255:
        -: 1256:      {
    #####: 1257:        tmp___1 = outcnt;
    #####: 1258:        outcnt++;
    #####: 1259:        outbuf[tmp___1] = (uch)((int)bi_buf & 255);
        -: 1260:
    #####: 1261:        tmp___2 = outcnt;
    #####: 1262:        outcnt++;
    #####: 1263:        outbuf[tmp___2] = (uch)((int)bi_buf >> 8);
    #####: 1264:        { flush_outbuf(); }
        -: 1265:      }
    #####: 1266:      bi_buf = (unsigned short)((int)((ush)value) >> (16UL * sizeof(char) -
        -: 1267:                                                      (unsigned long)bi_valid));
    #####: 1268:      bi_valid = (int)((unsigned long)bi_valid +
        -: 1269:                       ((unsigned long)length - 16UL * sizeof(char)));
        -: 1270:    } else {
    #####: 1271:      bi_buf = (unsigned short)((int)bi_buf | (value << bi_valid));
    #####: 1272:      bi_valid += length;
        -: 1273:    }
        -: 1274:  }
    #####: 1275:}
    #####: 1276:unsigned int bi_reverse(unsigned int code, int len) {
        -: 1277:  register unsigned int res;
        -: 1278:
        -: 1279:  {
    #####: 1280:    res = 0U;
        -: 1281:    {
        -: 1282:      while (1) {
        -: 1283:        ;
    #####: 1284:        res |= code & 1U;
    #####: 1285:        code >>= 1;
    #####: 1286:        res <<= 1;
    #####: 1287:        len--;
    #####: 1288:        if (!(len > 0)) {
    #####: 1289:          goto while_break;
        -: 1290:        }
        -: 1291:      }
    #####: 1292:    while_break: /* CIL Label */;
        -: 1293:    }
    #####: 1294:    return (res >> 1);
        -: 1295:  }
        -: 1296:}
    #####: 1297:void bi_windup(void) {
        -: 1298:
        -: 1299:  unsigned int tmp___3;
        -: 1300:
        -: 1301:  {
        -: 1302:
    #####: 1303:    tmp___3 = outcnt;
    #####: 1304:    outcnt++;
    #####: 1305:    outbuf[tmp___3] = (uch)bi_buf;
        -: 1306:  }
    #####: 1307:}
        -: 1308:
        -: 1309:int level;
        -: 1310:void ct_init(ush *attr, int *methodp);
        -: 1311:int ct_tally(int dist, int lc);
        -: 1312:ulg flush_block(char *buf, ulg stored_len, int eof);
        -: 1313:static int extra_lbits[29] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2,
        -: 1314:                              2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};
        -: 1315:static int extra_dbits[30] = {0, 0, 0,  0,  1,  1,  2,  2,  3,  3,
        -: 1316:                              4, 4, 5,  5,  6,  6,  7,  7,  8,  8,
        -: 1317:                              9, 9, 10, 10, 11, 11, 12, 12, 13, 13};
        -: 1318:static int extra_blbits[19] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        -: 1319:                               0, 0, 0, 0, 0, 0, 2, 3, 7};
        -: 1320:static ct_data dyn_ltree[573];
        -: 1321:static ct_data dyn_dtree[61];
        -: 1322:static ct_data static_ltree[288];
        -: 1323:static ct_data static_dtree[30];
        -: 1324:static ct_data bl_tree[39];
        -: 1325:static tree_desc l_desc = {dyn_ltree, static_ltree, extra_lbits, 257, 286, 15,
        -: 1326:                           0};
        -: 1327:static tree_desc d_desc = {dyn_dtree, static_dtree, extra_dbits, 0, 30, 15, 0};
        -: 1328:static tree_desc bl_desc = {bl_tree, (ct_data *)0, extra_blbits, 0, 19, 7, 0};
        -: 1329:static ush bl_count[16];
        -: 1330:static uch bl_order[19] = {(uch)16, (uch)17, (uch)18, (uch)0,  (uch)8,
        -: 1331:                           (uch)7,  (uch)9,  (uch)6,  (uch)10, (uch)5,
        -: 1332:                           (uch)11, (uch)4,  (uch)12, (uch)3,  (uch)13,
        -: 1333:                           (uch)2,  (uch)14, (uch)1,  (uch)15};
        -: 1334:static int heap[573];
        -: 1335:static int heap_len;
        -: 1336:static int heap_max;
        -: 1337:static uch depth[573];
        -: 1338:static uch length_code[256];
        -: 1339:static uch dist_code[512];
        -: 1340:static int base_length[29];
        -: 1341:static int base_dist[30];
        -: 1342:static uch flag_buf[4096];
        -: 1343:static unsigned int last_lit;
        -: 1344:static unsigned int last_dist;
        -: 1345:static unsigned int last_flags;
        -: 1346:static uch flags;
        -: 1347:static uch flag_bit;
        -: 1348:
        -: 1349:static ulg compressed_len;
        -: 1350:
        -: 1351:long block_start;
        -: 1352:unsigned int strstart;
        -: 1353:static void init_block(void);
        -: 1354:static void pqdownheap(ct_data *tree, int k);
        -: 1355:static void gen_bitlen(tree_desc *desc);
        -: 1356:static void gen_codes(ct_data *tree, int max_code);
        -: 1357:static void build_tree___0(tree_desc *desc);
        -: 1358:static void scan_tree(ct_data *tree, int max_code);
        -: 1359:static void send_tree(ct_data *tree, int max_code);
        -: 1360:static int build_bl_tree(void);
        -: 1361:static void send_all_trees(int lcodes, int dcodes, int blcodes);
        -: 1362:static void compress_block(ct_data *ltree, ct_data *dtree);
        -: 1363:static void set_file_type(void);
    #####: 1364:void ct_init(ush *attr, int *methodp) {
        -: 1365:  int n;
        -: 1366:
        -: 1367:  int length;
        -: 1368:  int code;
        -: 1369:  int dist;
        -: 1370:  int tmp;
        -: 1371:  int tmp___0;
        -: 1372:  int tmp___1;
        -: 1373:
        -: 1374:  {
        -: 1375:
    #####: 1376:    length = 0;
    #####: 1377:    code = 0;
        -: 1378:    {
        -: 1379:      while (1) {
        -: 1380:        ;
    #####: 1381:        if (!(code < 28)) {
    #####: 1382:          goto while_break;
        -: 1383:        }
    #####: 1384:        base_length[code] = length;
    #####: 1385:        n = 0;
        -: 1386:        {
        -: 1387:          while (1) {
        -: 1388:            ;
    #####: 1389:            if (!(n < 1 << extra_lbits[code])) {
    #####: 1390:              goto while_break___0;
        -: 1391:            }
    #####: 1392:            tmp = length;
    #####: 1393:            length++;
    #####: 1394:            length_code[tmp] = (uch)code;
    #####: 1395:            n++;
        -: 1396:          }
    #####: 1397:        while_break___0: /* CIL Label */;
        -: 1398:        }
    #####: 1399:        code++;
        -: 1400:      }
    #####: 1401:    while_break: /* CIL Label */;
        -: 1402:    }
        -: 1403:
    #####: 1404:    dist = 0;
    #####: 1405:    code = 0;
        -: 1406:    {
        -: 1407:      while (1) {
        -: 1408:        ;
    #####: 1409:        if (!(code < 16)) {
    #####: 1410:          goto while_break___1;
        -: 1411:        }
    #####: 1412:        base_dist[code] = dist;
    #####: 1413:        n = 0;
        -: 1414:        {
        -: 1415:          while (1) {
        -: 1416:            ;
    #####: 1417:            if (!(n < 1 << extra_dbits[code])) {
    #####: 1418:              goto while_break___2;
        -: 1419:            }
    #####: 1420:            tmp___0 = dist;
    #####: 1421:            dist++;
    #####: 1422:            dist_code[tmp___0] = (uch)code;
    #####: 1423:            n++;
        -: 1424:          }
    #####: 1425:        while_break___2: /* CIL Label */;
        -: 1426:        }
    #####: 1427:        code++;
        -: 1428:      }
    #####: 1429:    while_break___1: /* CIL Label */;
        -: 1430:    }
    #####: 1431:    dist >>= 7;
        -: 1432:    {
        -: 1433:      while (1) {
        -: 1434:        ;
    #####: 1435:        if (!(code < 30)) {
    #####: 1436:          goto while_break___3;
        -: 1437:        }
    #####: 1438:        base_dist[code] = dist << 7;
    #####: 1439:        n = 0;
        -: 1440:        {
        -: 1441:          while (1) {
        -: 1442:            ;
    #####: 1443:            if (!(n < 1 << (extra_dbits[code] - 7))) {
    #####: 1444:              goto while_break___4;
        -: 1445:            }
    #####: 1446:            tmp___1 = dist;
    #####: 1447:            dist++;
    #####: 1448:            dist_code[256 + tmp___1] = (uch)code;
    #####: 1449:            n++;
        -: 1450:          }
    #####: 1451:        while_break___4: /* CIL Label */;
        -: 1452:        }
    #####: 1453:        code++;
        -: 1454:      }
    #####: 1455:    while_break___3: /* CIL Label */;
        -: 1456:    }
        -: 1457:
    #####: 1458:    { init_block(); }
        -: 1459:  }
    #####: 1460:}
    #####: 1461:static void init_block(void) {
        -: 1462:  int n;
        -: 1463:
        -: 1464:  {
    #####: 1465:    n = 0;
        -: 1466:    {
        -: 1467:      while (1) {
        -: 1468:        ;
    #####: 1469:        if (!(n < 286)) {
    #####: 1470:          goto while_break;
        -: 1471:        }
    #####: 1472:        dyn_ltree[n].fc.freq = (ush)0;
    #####: 1473:        n++;
        -: 1474:      }
    #####: 1475:    while_break: /* CIL Label */;
        -: 1476:    }
    #####: 1477:    n = 0;
        -: 1478:    {
        -: 1479:      while (1) {
        -: 1480:        ;
    #####: 1481:        if (!(n < 30)) {
    #####: 1482:          goto while_break___0;
        -: 1483:        }
    #####: 1484:        dyn_dtree[n].fc.freq = (ush)0;
    #####: 1485:        n++;
        -: 1486:      }
    #####: 1487:    while_break___0: /* CIL Label */;
        -: 1488:    }
    #####: 1489:    n = 0;
        -: 1490:    {
        -: 1491:      while (1) {
        -: 1492:        ;
    #####: 1493:        if (!(n < 19)) {
    #####: 1494:          goto while_break___1;
        -: 1495:        }
    #####: 1496:        bl_tree[n].fc.freq = (ush)0;
    #####: 1497:        n++;
        -: 1498:      }
    #####: 1499:    while_break___1: /* CIL Label */;
        -: 1500:    }
    #####: 1501:    dyn_ltree[256].fc.freq = (ush)1;
        -: 1502:
    #####: 1503:    last_flags = 0U;
    #####: 1504:    last_dist = last_flags;
    #####: 1505:    last_lit = last_dist;
        -: 1506:  }
    #####: 1507:}
    #####: 1508:static void pqdownheap(ct_data *tree, int k) {
        -: 1509:  int v;
        -: 1510:  int j___0;
        -: 1511:
        -: 1512:  {
    #####: 1513:    v = heap[k];
    #####: 1514:    j___0 = k << 1;
        -: 1515:    {
        -: 1516:      while (1) {
        -: 1517:        ;
    #####: 1518:        if (!(j___0 <= heap_len)) {
    #####: 1519:          goto while_break;
        -: 1520:        }
    #####: 1521:        if (j___0 < heap_len) {
    #####: 1522:          if ((int)(tree + heap[j___0 + 1])->fc.freq <
    #####: 1523:              (int)(tree + heap[j___0])->fc.freq) {
    #####: 1524:            j___0++;
        -: 1525:          } else {
    #####: 1526:            if ((int)(tree + heap[j___0 + 1])->fc.freq ==
    #####: 1527:                (int)(tree + heap[j___0])->fc.freq) {
    #####: 1528:              if ((int)depth[heap[j___0 + 1]] <= (int)depth[heap[j___0]]) {
    #####: 1529:                j___0++;
        -: 1530:              }
        -: 1531:            }
        -: 1532:          }
        -: 1533:        }
    #####: 1534:        if ((int)(tree + v)->fc.freq < (int)(tree + heap[j___0])->fc.freq) {
    #####: 1535:          goto while_break;
        -: 1536:        } else {
    #####: 1537:          if ((int)(tree + v)->fc.freq == (int)(tree + heap[j___0])->fc.freq) {
    #####: 1538:            if ((int)depth[v] <= (int)depth[heap[j___0]]) {
    #####: 1539:              goto while_break;
        -: 1540:            }
        -: 1541:          }
        -: 1542:        }
    #####: 1543:        heap[k] = heap[j___0];
    #####: 1544:        k = j___0;
    #####: 1545:        j___0 <<= 1;
        -: 1546:      }
    #####: 1547:    while_break: /* CIL Label */;
        -: 1548:    }
    #####: 1549:    heap[k] = v;
        -: 1550:  }
    #####: 1551:}
    #####: 1552:static void gen_bitlen(tree_desc *desc) {
        -: 1553:  ct_data *tree;
        -: 1554:
        -: 1555:  int max_code;
        -: 1556:
        -: 1557:  int h;
        -: 1558:  int n;
        -: 1559:
        -: 1560:  int bits;
        -: 1561:
        -: 1562:  {
    #####: 1563:    tree = desc->dyn_tree;
        -: 1564:
    #####: 1565:    max_code = desc->max_code;
        -: 1566:
    #####: 1567:    bits = 0;
        -: 1568:    {
        -: 1569:      while (1) {
        -: 1570:        ;
    #####: 1571:        if (!(bits <= 15)) {
    #####: 1572:          goto while_break;
        -: 1573:        }
    #####: 1574:        bl_count[bits] = (ush)0;
    #####: 1575:        bits++;
        -: 1576:      }
    #####: 1577:    while_break: /* CIL Label */;
        -: 1578:    }
        -: 1579:
    #####: 1580:    h = heap_max + 1;
        -: 1581:    {
        -: 1582:      while (1) {
        -: 1583:        ;
    #####: 1584:        if (!(h < 573)) {
    #####: 1585:          goto while_break___0;
        -: 1586:        }
    #####: 1587:        n = heap[h];
    #####: 1588:        bits = (int)(tree + (int)(tree + n)->dl.dad)->dl.len + 1;
        -: 1589:
    #####: 1590:        (tree + n)->dl.len = (ush)bits;
    #####: 1591:        if (n > max_code) {
    #####: 1592:          goto __Cont;
        -: 1593:        }
    #####: 1594:        bl_count[bits] = (ush)((int)bl_count[bits] + 1);
        -: 1595:
    #####: 1596:      __Cont:
    #####: 1597:        h++;
        -: 1598:      }
    #####: 1599:    while_break___0: /* CIL Label */;
        -: 1600:    }
        -: 1601:  }
    #####: 1602:}
    #####: 1603:static void gen_codes(ct_data *tree, int max_code) {
        -: 1604:  ush next_code[16];
        -: 1605:  ush code;
        -: 1606:  int bits;
        -: 1607:  int n;
        -: 1608:  int len;
        -: 1609:  ush tmp;
        -: 1610:
        -: 1611:  {
        -: 1612:
    #####: 1613:    bits = 1;
        -: 1614:    {
        -: 1615:      while (1) {
        -: 1616:        ;
    #####: 1617:        if (!(bits <= 15)) {
    #####: 1618:          goto while_break;
        -: 1619:        }
    #####: 1620:        code = (ush)(((int)code + (int)bl_count[bits - 1]) << 1);
    #####: 1621:        next_code[bits] = code;
    #####: 1622:        bits++;
        -: 1623:      }
    #####: 1624:    while_break: /* CIL Label */;
        -: 1625:    }
    #####: 1626:    n = 0;
        -: 1627:    {
        -: 1628:      while (1) {
        -: 1629:        ;
    #####: 1630:        if (!(n <= max_code)) {
    #####: 1631:          goto while_break___0;
        -: 1632:        }
    #####: 1633:        len = (int)(tree + n)->dl.len;
        -: 1634:
        -: 1635:        {
    #####: 1636:          tmp = next_code[len];
    #####: 1637:          next_code[len] = (ush)((int)next_code[len] + 1);
    #####: 1638:          (tree + n)->fc.code = (ush)bi_reverse((unsigned int)tmp, len);
        -: 1639:        }
        -: 1640:
    #####: 1641:        n++;
        -: 1642:      }
    #####: 1643:    while_break___0: /* CIL Label */;
        -: 1644:    }
        -: 1645:  }
    #####: 1646:}
    #####: 1647:static void build_tree___0(tree_desc *desc) {
        -: 1648:  ct_data *tree;
        -: 1649:
        -: 1650:  int elems;
        -: 1651:  int n;
        -: 1652:  int m;
        -: 1653:  int max_code;
        -: 1654:  int node;
        -: 1655:
        -: 1656:  int tmp___0;
        -: 1657:  int tmp___1;
        -: 1658:  ush tmp___2;
        -: 1659:  int tmp___3;
        -: 1660:
        -: 1661:  {
    #####: 1662:    tree = desc->dyn_tree;
        -: 1663:
    #####: 1664:    elems = desc->elems;
        -: 1665:
    #####: 1666:    node = elems;
    #####: 1667:    heap_len = 0;
    #####: 1668:    heap_max = 573;
    #####: 1669:    n = 0;
        -: 1670:    {
        -: 1671:      while (1) {
        -: 1672:        ;
    #####: 1673:        if (!(n < elems)) {
    #####: 1674:          goto while_break;
        -: 1675:        }
    #####: 1676:        if ((int)(tree + n)->fc.freq != 0) {
    #####: 1677:          heap_len++;
    #####: 1678:          max_code = n;
    #####: 1679:          heap[heap_len] = max_code;
        -: 1680:
        -: 1681:        } else {
    #####: 1682:          (tree + n)->dl.len = (ush)0;
        -: 1683:        }
    #####: 1684:        n++;
        -: 1685:      }
    #####: 1686:    while_break: /* CIL Label */;
        -: 1687:    }
        -: 1688:
    #####: 1689:    desc->max_code = max_code;
        -: 1690:
        -: 1691:    {
        -: 1692:      while (1) {
        -: 1693:        ;
    #####: 1694:        if (!(n >= 1)) {
    #####: 1695:          goto while_break___1;
        -: 1696:        }
        -: 1697:        {
    #####: 1698:          pqdownheap(tree, n);
    #####: 1699:          n--;
        -: 1700:        }
        -: 1701:      }
    #####: 1702:    while_break___1: /* CIL Label */;
        -: 1703:    }
        -: 1704:    {
        -: 1705:      while (1) {
        -: 1706:        ;
        -: 1707:        {
    #####: 1708:          n = heap[1];
    #####: 1709:          tmp___0 = heap_len;
    #####: 1710:          heap_len--;
    #####: 1711:          heap[1] = heap[tmp___0];
    #####: 1712:          pqdownheap(tree, 1);
    #####: 1713:          m = heap[1];
    #####: 1714:          heap_max--;
    #####: 1715:          heap[heap_max] = n;
    #####: 1716:          heap_max--;
    #####: 1717:          heap[heap_max] = m;
    #####: 1718:          (tree + node)->fc.freq =
    #####: 1719:              (ush)((int)(tree + n)->fc.freq + (int)(tree + m)->fc.freq);
        -: 1720:        }
    #####: 1721:        { tmp___1 = (int)depth[n]; }
        -: 1722:
        -: 1723:        {
    #####: 1724:          depth[node] = (uch)(tmp___1 + 1);
    #####: 1725:          tmp___2 = (ush)node;
    #####: 1726:          (tree + m)->dl.dad = tmp___2;
    #####: 1727:          (tree + n)->dl.dad = tmp___2;
    #####: 1728:          tmp___3 = node;
    #####: 1729:          node++;
    #####: 1730:          heap[1] = tmp___3;
    #####: 1731:          pqdownheap(tree, 1);
        -: 1732:        }
    #####: 1733:        if (!(heap_len >= 2)) {
    #####: 1734:          goto while_break___2;
        -: 1735:        }
        -: 1736:      }
    #####: 1737:    while_break___2: /* CIL Label */;
        -: 1738:    }
        -: 1739:    {
    #####: 1740:      heap_max--;
        -: 1741:
    #####: 1742:      gen_bitlen(desc);
    #####: 1743:      gen_codes(tree, max_code);
        -: 1744:    }
        -: 1745:  }
    #####: 1746:}
    #####: 1747:static void scan_tree(ct_data *tree, int max_code) {
        -: 1748:  int n;
        -: 1749:
        -: 1750:  int curlen;
        -: 1751:  int nextlen;
        -: 1752:  int count;
        -: 1753:  int max_count;
        -: 1754:  int min_count;
        -: 1755:
        -: 1756:  {
        -: 1757:
    #####: 1758:    nextlen = (int)(tree + 0)->dl.len;
    #####: 1759:    count = 0;
    #####: 1760:    max_count = 7;
    #####: 1761:    min_count = 4;
        -: 1762:
    #####: 1763:    n = 0;
        -: 1764:    {
        -: 1765:      while (1) {
        -: 1766:        ;
    #####: 1767:        if (!(n <= max_code)) {
    #####: 1768:          goto while_break;
        -: 1769:        }
    #####: 1770:        curlen = nextlen;
    #####: 1771:        nextlen = (int)(tree + (n + 1))->dl.len;
    #####: 1772:        count++;
    #####: 1773:        if (count < max_count) {
    #####: 1774:          if (curlen == nextlen) {
    #####: 1775:            goto __Cont;
        -: 1776:          } else {
    #####: 1777:            goto _L;
        -: 1778:          }
        -: 1779:        } else {
    #####: 1780:        _L:
    #####: 1781:          if (count < min_count) {
    #####: 1782:            bl_tree[curlen].fc.freq =
    #####: 1783:                (ush)((int)bl_tree[curlen].fc.freq + count);
        -: 1784:          } else {
        -: 1785:
        -: 1786:            {
    #####: 1787:              bl_tree[curlen].fc.freq = (ush)((int)bl_tree[curlen].fc.freq + 1);
        -: 1788:            }
    #####: 1789:            bl_tree[16].fc.freq = (ush)((int)bl_tree[16].fc.freq + 1);
        -: 1790:          }
        -: 1791:        }
    #####: 1792:        count = 0;
        -: 1793:
    #####: 1794:      __Cont:
    #####: 1795:        n++;
        -: 1796:      }
    #####: 1797:    while_break: /* CIL Label */;
        -: 1798:    }
        -: 1799:  }
    #####: 1800:}
    #####: 1801:static void send_tree(ct_data *tree, int max_code) {
        -: 1802:  int n;
        -: 1803:
        -: 1804:  int curlen;
        -: 1805:  int nextlen;
        -: 1806:  int count;
        -: 1807:  int max_count;
        -: 1808:  int min_count;
        -: 1809:
        -: 1810:  {
        -: 1811:
    #####: 1812:    nextlen = (int)(tree + 0)->dl.len;
    #####: 1813:    count = 0;
    #####: 1814:    max_count = 7;
    #####: 1815:    min_count = 4;
        -: 1816:
    #####: 1817:    n = 0;
        -: 1818:    {
        -: 1819:      while (1) {
        -: 1820:        ;
    #####: 1821:        if (!(n <= max_code)) {
    #####: 1822:          goto while_break;
        -: 1823:        }
    #####: 1824:        curlen = nextlen;
    #####: 1825:        nextlen = (int)(tree + (n + 1))->dl.len;
    #####: 1826:        count++;
    #####: 1827:        if (count < max_count) {
    #####: 1828:          if (curlen == nextlen) {
    #####: 1829:            goto __Cont;
        -: 1830:          } else {
    #####: 1831:            goto _L;
        -: 1832:          }
        -: 1833:        } else {
    #####: 1834:        _L:
    #####: 1835:          if (count < min_count) {
        -: 1836:
        -: 1837:            while (1) {
        -: 1838:              ;
        -: 1839:              {
    #####: 1840:                send_bits((int)bl_tree[curlen].fc.code,
    #####: 1841:                          (int)bl_tree[curlen].dl.len);
    #####: 1842:                count--;
        -: 1843:              }
    #####: 1844:              if (!(count != 0)) {
    #####: 1845:                goto while_break___0;
        -: 1846:              }
        -: 1847:            }
    #####: 1848:          while_break___0: /* CIL Label */;
        -: 1849:
        -: 1850:          } else {
        -: 1851:
        -: 1852:            {
        -: 1853:
    #####: 1854:              send_bits((int)bl_tree[curlen].fc.code,
    #####: 1855:                        (int)bl_tree[curlen].dl.len);
    #####: 1856:              count--;
        -: 1857:            }
        -: 1858:            {
    #####: 1859:              send_bits((int)bl_tree[16].fc.code, (int)bl_tree[16].dl.len);
    #####: 1860:              send_bits(count - 3, 2);
        -: 1861:            }
        -: 1862:          }
        -: 1863:        }
    #####: 1864:        count = 0;
        -: 1865:
    #####: 1866:      __Cont:
    #####: 1867:        n++;
        -: 1868:      }
    #####: 1869:    while_break: /* CIL Label */;
        -: 1870:    }
        -: 1871:  }
    #####: 1872:}
    #####: 1873:static int build_bl_tree(void) {
        -: 1874:  int max_blindex;
        -: 1875:
        -: 1876:  {
        -: 1877:    {
    #####: 1878:      scan_tree(dyn_ltree, l_desc.max_code);
    #####: 1879:      scan_tree(dyn_dtree, d_desc.max_code);
    #####: 1880:      build_tree___0(&bl_desc);
    #####: 1881:      max_blindex = 18;
        -: 1882:    }
        -: 1883:    {
        -: 1884:      while (1) {
        -: 1885:        ;
        -: 1886:
    #####: 1887:        if ((int)bl_tree[bl_order[max_blindex]].dl.len != 0) {
    #####: 1888:          goto while_break;
        -: 1889:        }
    #####: 1890:        max_blindex--;
        -: 1891:      }
    #####: 1892:    while_break: /* CIL Label */;
        -: 1893:    }
        -: 1894:
    #####: 1895:    return (max_blindex);
        -: 1896:  }
        -: 1897:}
    #####: 1898:static void send_all_trees(int lcodes, int dcodes, int blcodes) {
        -: 1899:  int rank;
        -: 1900:
        -: 1901:  {
        -: 1902:    {
    #####: 1903:      send_bits(lcodes - 257, 5);
    #####: 1904:      send_bits(dcodes - 1, 5);
    #####: 1905:      send_bits(blcodes - 4, 4);
    #####: 1906:      rank = 0;
        -: 1907:    }
        -: 1908:    {
        -: 1909:      while (1) {
        -: 1910:        ;
    #####: 1911:        if (!(rank < blcodes)) {
    #####: 1912:          goto while_break;
        -: 1913:        }
        -: 1914:        {
    #####: 1915:          send_bits((int)bl_tree[bl_order[rank]].dl.len, 3);
    #####: 1916:          rank++;
        -: 1917:        }
        -: 1918:      }
    #####: 1919:    while_break: /* CIL Label */;
        -: 1920:    }
        -: 1921:    {
    #####: 1922:      send_tree(dyn_ltree, lcodes - 1);
    #####: 1923:      send_tree(dyn_dtree, dcodes - 1);
        -: 1924:    }
        -: 1925:  }
    #####: 1926:}
    #####: 1927:ulg flush_block(char *buf, ulg stored_len, int eof) {
        -: 1928:
        -: 1929:  int max_blindex;
        -: 1930:
        -: 1931:  {
    #####: 1932:    flag_buf[last_flags] = flags;
        -: 1933:
        -: 1934:    {
    #####: 1935:      build_tree___0(&l_desc);
    #####: 1936:      build_tree___0(&d_desc);
    #####: 1937:      max_blindex = build_bl_tree();
        -: 1938:    }
        -: 1939:
        -: 1940:    {
        -: 1941:
    #####: 1942:      send_bits((2 << 1) + eof, 3);
    #####: 1943:      send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
    #####: 1944:      compress_block(dyn_ltree, dyn_dtree);
        -: 1945:    }
    #####: 1946:    { init_block(); }
    #####: 1947:    if (eof) {
        -: 1948:
    #####: 1949:      bi_windup();
        -: 1950:    }
    #####: 1951:    return (compressed_len >> 3);
        -: 1952:  }
        -: 1953:}
    #####: 1954:int ct_tally(int dist, int lc) {
        -: 1955:  unsigned int tmp;
        -: 1956:  int tmp___0;
        -: 1957:  unsigned int tmp___1;
        -: 1958:  unsigned int tmp___2;
        -: 1959:  ulg out_length;
        -: 1960:  ulg in_length;
        -: 1961:  int dcode;
        -: 1962:  int tmp___3;
        -: 1963:
        -: 1964:  {
    #####: 1965:    tmp = last_lit;
    #####: 1966:    last_lit++;
    #####: 1967:    inbuf[tmp] = (uch)lc;
    #####: 1968:    if (dist == 0) {
    #####: 1969:      dyn_ltree[lc].fc.freq = (ush)((int)dyn_ltree[lc].fc.freq + 1);
        -: 1970:    } else {
    #####: 1971:      dist--;
    #####: 1972:      dyn_ltree[((int)length_code[lc] + 256) + 1].fc.freq =
    #####: 1973:          (ush)((int)dyn_ltree[((int)length_code[lc] + 256) + 1].fc.freq + 1);
    #####: 1974:      if (dist < 256) {
    #####: 1975:        tmp___0 = (int)dist_code[dist];
        -: 1976:      } else {
    #####: 1977:        tmp___0 = (int)dist_code[256 + (dist >> 7)];
        -: 1978:      }
    #####: 1979:      dyn_dtree[tmp___0].fc.freq = (ush)((int)dyn_dtree[tmp___0].fc.freq + 1);
    #####: 1980:      tmp___1 = last_dist;
    #####: 1981:      last_dist++;
    #####: 1982:      d_buf[tmp___1] = (ush)dist;
    #####: 1983:      flags = (uch)((int)flags | (int)flag_bit);
        -: 1984:    }
    #####: 1985:    flag_bit = (uch)((int)flag_bit << 1);
    #####: 1986:    if ((last_lit & 7U) == 0U) {
    #####: 1987:      tmp___2 = last_flags;
    #####: 1988:      last_flags++;
    #####: 1989:      flag_buf[tmp___2] = flags;
    #####: 1990:      flags = (uch)0;
    #####: 1991:      flag_bit = (uch)1;
        -: 1992:    }
        -: 1993:    {
    #####: 1994:      if ((last_lit & 4095U) == 0U) {
    #####: 1995:        out_length = (ulg)last_lit * 8UL;
    #####: 1996:        in_length = (ulg)strstart - (ulg)block_start;
    #####: 1997:        dcode = 0;
        -: 1998:        {
        -: 1999:          while (1) {
        -: 2000:            ;
    #####: 2001:            if (!(dcode < 30)) {
    #####: 2002:              goto while_break;
        -: 2003:            }
    #####: 2004:            out_length += (ulg)dyn_dtree[dcode].fc.freq *
    #####: 2005:                          (ulg)(5L + (long)extra_dbits[dcode]);
    #####: 2006:            dcode++;
        -: 2007:          }
    #####: 2008:        while_break: /* CIL Label */;
        -: 2009:        }
    #####: 2010:        out_length >>= 3;
    #####: 2011:        if (last_dist < last_lit / 2U) {
    #####: 2012:          if (out_length < in_length / 2UL) {
    #####: 2013:            return (1);
        -: 2014:          }
        -: 2015:        }
        -: 2016:      }
        -: 2017:    }
        -: 2018:
    #####: 2019:    { tmp___3 = 0; }
    #####: 2020:    return (tmp___3);
        -: 2021:  }
        -: 2022:}
    #####: 2023:static void compress_block(ct_data *ltree, ct_data *dtree) {
        -: 2024:  unsigned int dist;
        -: 2025:  int lc;
        -: 2026:  unsigned int lx;
        -: 2027:  unsigned int dx;
        -: 2028:  unsigned int fx;
        -: 2029:  uch flag;
        -: 2030:  unsigned int code;
        -: 2031:  int extra;
        -: 2032:  unsigned int tmp;
        -: 2033:  unsigned int tmp___0;
        -: 2034:  unsigned int tmp___1;
        -: 2035:
        -: 2036:  {
    #####: 2037:    lx = 0U;
    #####: 2038:    dx = 0U;
    #####: 2039:    fx = 0U;
        -: 2040:
        -: 2041:    {
        -: 2042:
        -: 2043:      while (1) {
        -: 2044:        ;
    #####: 2045:        if ((lx & 7U) == 0U) {
    #####: 2046:          tmp = fx;
    #####: 2047:          fx++;
    #####: 2048:          flag = flag_buf[tmp];
        -: 2049:        }
    #####: 2050:        tmp___0 = lx;
    #####: 2051:        lx++;
    #####: 2052:        lc = (int)inbuf[tmp___0];
    #####: 2053:        if (((int)flag & 1) == 0) {
        -: 2054:
    #####: 2055:          send_bits((int)(ltree + lc)->fc.code, (int)(ltree + lc)->dl.len);
        -: 2056:
        -: 2057:        } else {
        -: 2058:          {
    #####: 2059:            code = (unsigned int)length_code[lc];
    #####: 2060:            send_bits((int)(ltree + ((code + 256U) + 1U))->fc.code,
    #####: 2061:                      (int)(ltree + ((code + 256U) + 1U))->dl.len);
    #####: 2062:            extra = extra_lbits[code];
        -: 2063:          }
        -: 2064:          {
        -: 2065:
    #####: 2066:            lc -= base_length[code];
    #####: 2067:            send_bits(lc, extra);
        -: 2068:          }
    #####: 2069:          tmp___1 = dx;
    #####: 2070:          dx++;
    #####: 2071:          dist = (unsigned int)d_buf[tmp___1];
    #####: 2072:          if (dist < 256U) {
    #####: 2073:            code = (unsigned int)dist_code[dist];
        -: 2074:          } else {
    #####: 2075:            code = (unsigned int)dist_code[256U + (dist >> 7)];
        -: 2076:          }
        -: 2077:          {
    #####: 2078:            send_bits((int)(dtree + code)->fc.code,
    #####: 2079:                      (int)(dtree + code)->dl.len);
    #####: 2080:            extra = extra_dbits[code];
        -: 2081:          }
        -: 2082:          {
        -: 2083:
    #####: 2084:            dist -= (unsigned int)base_dist[code];
    #####: 2085:            send_bits((int)dist, extra);
        -: 2086:          }
        -: 2087:        }
    #####: 2088:        flag = (uch)((int)flag >> 1);
    #####: 2089:        if (!(lx < last_lit)) {
    #####: 2090:          goto while_break;
        -: 2091:        }
        -: 2092:      }
    #####: 2093:    while_break: /* CIL Label */;
        -: 2094:    }
    #####: 2095:    { send_bits((int)(ltree + 256)->fc.code, (int)(ltree + 256)->dl.len); }
        -: 2096:  }
    #####: 2097:}
        -: 2098:
        -: 2099:void lm_init(int pack_level, ush *flags___0);
        -: 2100:ulg deflate(void);
        -: 2101:ulg window_size = 65536UL;
        -: 2102:static unsigned int ins_h;
        -: 2103:unsigned int prev_length;
        -: 2104:unsigned int match_start;
        -: 2105:
        -: 2106:static unsigned int lookahead;
        -: 2107:unsigned int max_chain_length;
        -: 2108:static unsigned int max_lazy_match;
        -: 2109:
        -: 2110:unsigned int good_match;
        -: 2111:
        -: 2112:static config configuration_table[10] = {
        -: 2113:    {(ush)0, (ush)0, (ush)0, (ush)0},
        -: 2114:    {(ush)4, (ush)4, (ush)8, (ush)4},
        -: 2115:    {(ush)4, (ush)5, (ush)16, (ush)8},
        -: 2116:    {(ush)4, (ush)6, (ush)32, (ush)32},
        -: 2117:    {(ush)4, (ush)4, (ush)16, (ush)16},
        -: 2118:    {(ush)8, (ush)16, (ush)32, (ush)32},
        -: 2119:    {(ush)8, (ush)16, (ush)128, (ush)128},
        -: 2120:    {(ush)8, (ush)32, (ush)128, (ush)256},
        -: 2121:    {(ush)32, (ush)128, (ush)258, (ush)1024},
        -: 2122:    {(ush)32, (ush)258, (ush)258, (ush)4096}};
        -: 2123:static void fill_window(void);
        -: 2124:static ulg deflate_fast(void);
        -: 2125:int longest_match(IPos cur_match);
    #####: 2126:void lm_init(int pack_level, ush *flags___0) {
        -: 2127:
        -: 2128:  unsigned int tmp;
        -: 2129:
        -: 2130:  {
        -: 2131:
        -: 2132:    {
        -: 2133:
    #####: 2134:      max_lazy_match = (unsigned int)configuration_table[pack_level].max_lazy;
    #####: 2135:      good_match = (unsigned int)configuration_table[pack_level].good_length;
        -: 2136:
    #####: 2137:      max_chain_length =
    #####: 2138:          (unsigned int)configuration_table[pack_level].max_chain;
        -: 2139:    }
        -: 2140:
    #####: 2141:    { tmp = 32768U; }
        -: 2142:
    #####: 2143:    { lookahead = (unsigned int)(*read_buf)((char *)(window), tmp); }
        -: 2144:  }
    #####: 2145:}
    #####: 2146:int longest_match(IPos cur_match) {
        -: 2147:  unsigned int chain_length;
        -: 2148:  register uch *scan;
        -: 2149:  register uch *match;
        -: 2150:  register int len;
        -: 2151:  int best_len;
        -: 2152:  IPos limit;
        -: 2153:  unsigned int tmp;
        -: 2154:  register uch *strend;
        -: 2155:
        -: 2156:  {
    #####: 2157:    chain_length = max_chain_length;
    #####: 2158:    scan = window + strstart;
    #####: 2159:    best_len = (int)prev_length;
    #####: 2160:    if (strstart > 32506U) {
    #####: 2161:      tmp = strstart - 32506U;
        -: 2162:    } else {
    #####: 2163:      tmp = 0U;
        -: 2164:    }
    #####: 2165:    limit = tmp;
    #####: 2166:    strend = (window + strstart) + 258;
        -: 2167:
    #####: 2168:    if (prev_length >= good_match) {
    #####: 2169:      chain_length >>= 2;
        -: 2170:    }
        -: 2171:    {
        -: 2172:      while (1) {
        -: 2173:        ;
    #####: 2174:        match = window + cur_match;
        -: 2175:
        -: 2176:        {
        -: 2177:
    #####: 2178:          if ((int)*match != (int)*scan) {
    #####: 2179:            goto __Cont;
        -: 2180:          } else {
    #####: 2181:            match++;
        -: 2182:          }
        -: 2183:        }
    #####: 2184:        scan += 2;
    #####: 2185:        match++;
        -: 2186:        {
        -: 2187:          while (1) {
        -: 2188:            ;
        -: 2189:
        -: 2190:            {
        -: 2191:
    #####: 2192:              if ((int)*scan == (int)*match) {
        -: 2193:
    #####: 2194:                scan++;
    #####: 2195:                match++;
        -: 2196:
        -: 2197:              } else {
    #####: 2198:                goto while_break___0;
        -: 2199:              }
        -: 2200:            }
        -: 2201:          }
    #####: 2202:        while_break___0: /* CIL Label */;
        -: 2203:        }
    #####: 2204:        len = 258 - (int)(strend - scan);
    #####: 2205:        scan = strend - 258;
    #####: 2206:        if (len > best_len) {
    #####: 2207:          match_start = cur_match;
    #####: 2208:          best_len = len;
        -: 2209:        }
    #####: 2210:      __Cont:
    #####: 2211:        cur_match = (IPos)prev[cur_match & 32767U];
    #####: 2212:        if (cur_match > limit) {
    #####: 2213:          chain_length--;
    #####: 2214:          if (!(chain_length != 0U)) {
    #####: 2215:            goto while_break;
        -: 2216:          }
        -: 2217:        } else {
    #####: 2218:          goto while_break;
        -: 2219:        }
        -: 2220:      }
    #####: 2221:    while_break: /* CIL Label */;
        -: 2222:    }
    #####: 2223:    return (best_len);
        -: 2224:  }
        -: 2225:}
    #####: 2226:static void fill_window(void) {
        -: 2227:  register unsigned int n;
        -: 2228:  register unsigned int m;
        -: 2229:  unsigned int more;
        -: 2230:  unsigned int tmp;
        -: 2231:  unsigned int tmp___0;
        -: 2232:
        -: 2233:  {
    #####: 2234:    more = (unsigned int)((window_size - (ulg)lookahead) - (ulg)strstart);
        -: 2235:
        -: 2236:    {
    #####: 2237:      if (strstart >= 65274U) {
        -: 2238:        {
    #####: 2239:          memcpy((void * /* __restrict  */)((char *)(window)),
        -: 2240:                 (void const * /* __restrict  */)((char *)(window) + 32768),
        -: 2241:                 (size_t)32768U);
        -: 2242:
    #####: 2243:          strstart -= 32768U;
        -: 2244:
    #####: 2245:          n = 0U;
        -: 2246:        }
        -: 2247:        {
        -: 2248:          while (1) {
        -: 2249:            ;
    #####: 2250:            if (!(n < (unsigned int)(1 << 15))) {
    #####: 2251:              goto while_break;
        -: 2252:            }
    #####: 2253:            m = (unsigned int)*((prev + 32768) + n);
    #####: 2254:            { tmp = m - 32768U; }
        -: 2255:
    #####: 2256:            *((prev + 32768) + n) = (Pos)tmp;
    #####: 2257:            n++;
        -: 2258:          }
    #####: 2259:        while_break: /* CIL Label */;
        -: 2260:        }
    #####: 2261:        n = 0U;
        -: 2262:        {
        -: 2263:          while (1) {
        -: 2264:            ;
    #####: 2265:            if (!(n < 32768U)) {
    #####: 2266:              goto while_break___0;
        -: 2267:            }
    #####: 2268:            m = (unsigned int)prev[n];
    #####: 2269:            { tmp___0 = m - 32768U; }
        -: 2270:
    #####: 2271:            prev[n] = (Pos)tmp___0;
    #####: 2272:            n++;
        -: 2273:          }
    #####: 2274:        while_break___0: /* CIL Label */;
        -: 2275:        }
        -: 2276:      }
        -: 2277:    }
        -: 2278:    {
        -: 2279:      {
    #####: 2280:        n = (unsigned int)(*read_buf)(((char *)(window) + strstart) + lookahead,
        -: 2281:                                      more);
        -: 2282:      }
        -: 2283:
    #####: 2284:      { lookahead += n; }
        -: 2285:    }
        -: 2286:  }
    #####: 2287:}
        -: 2288:
    #####: 2289:ulg deflate(void) {
        -: 2290:  IPos hash_head;
        -: 2291:  IPos prev_match;
        -: 2292:  int flush;
        -: 2293:  int match_available;
        -: 2294:  register unsigned int match_length;
        -: 2295:
        -: 2296:  char *tmp___1;
        -: 2297:  int tmp___2;
        -: 2298:  char *tmp___3;
        -: 2299:  ulg tmp___4;
        -: 2300:
        -: 2301:  {
    #####: 2302:    match_available = 0;
    #####: 2303:    match_length = 2U;
        -: 2304:
        -: 2305:    {
        -: 2306:      while (1) {
        -: 2307:        ;
    #####: 2308:        if (!(lookahead != 0U)) {
    #####: 2309:          goto while_break;
        -: 2310:        }
    #####: 2311:        ins_h = ((ins_h << 5) ^ (unsigned int)window[(strstart + 3U) - 1U]) &
        -: 2312:                ((unsigned int)(1 << 15) - 1U);
    #####: 2313:        hash_head = (IPos) * ((prev + 32768) + ins_h);
    #####: 2314:        prev[strstart & 32767U] = (ush)hash_head;
    #####: 2315:        *((prev + 32768) + ins_h) = (ush)strstart;
    #####: 2316:        prev_length = match_length;
    #####: 2317:        prev_match = match_start;
        -: 2318:
    #####: 2319:        if (hash_head != 0U) {
    #####: 2320:          if (prev_length < max_lazy_match) {
    #####: 2321:            if (strstart - hash_head <= 32506U) {
        -: 2322:              {
    #####: 2323:                match_length = (unsigned int)longest_match(hash_head);
        -: 2324:              }
        -: 2325:
    #####: 2326:              if (match_length == 3U) {
    #####: 2327:                if (strstart - match_start > 4096U) {
    #####: 2328:                  match_length--;
        -: 2329:                }
        -: 2330:              }
        -: 2331:            }
        -: 2332:          }
        -: 2333:        }
    #####: 2334:        if (prev_length >= 3U) {
    #####: 2335:          if (match_length <= prev_length) {
        -: 2336:            {
    #####: 2337:              flush = ct_tally((int)((strstart - 1U) - prev_match),
    #####: 2338:                               (int)(prev_length - 3U));
    #####: 2339:              lookahead -= prev_length - 1U;
    #####: 2340:              prev_length -= 2U;
        -: 2341:            }
        -: 2342:            {
        -: 2343:              while (1) {
        -: 2344:                ;
    #####: 2345:                strstart++;
    #####: 2346:                ins_h = ((ins_h << 5) ^
    #####: 2347:                         (unsigned int)window[(strstart + 3U) - 1U]) &
        -: 2348:                        ((unsigned int)(1 << 15) - 1U);
    #####: 2349:                hash_head = (IPos) * ((prev + 32768) + ins_h);
    #####: 2350:                prev[strstart & 32767U] = (ush)hash_head;
    #####: 2351:                *((prev + 32768) + ins_h) = (ush)strstart;
    #####: 2352:                prev_length--;
    #####: 2353:                if (!(prev_length != 0U)) {
    #####: 2354:                  goto while_break___0;
        -: 2355:                }
        -: 2356:              }
    #####: 2357:            while_break___0: /* CIL Label */;
        -: 2358:            }
    #####: 2359:            match_available = 0;
    #####: 2360:            match_length = 2U;
    #####: 2361:            strstart++;
        -: 2362:
        -: 2363:          } else {
    #####: 2364:            goto _L;
        -: 2365:          }
        -: 2366:        } else {
    #####: 2367:        _L:
    #####: 2368:          if (match_available) {
        -: 2369:            {
    #####: 2370:              tmp___2 = ct_tally(0, (int)window[strstart - 1U]);
        -: 2371:            }
    #####: 2372:            if (tmp___2) {
        -: 2373:              {
    #####: 2374:                tmp___1 = (char *)(&window[(unsigned int)block_start]);
        -: 2375:              }
        -: 2376:
    #####: 2377:              { flush_block(tmp___1, (ulg)((long)strstart - block_start), 0); }
        -: 2378:            }
    #####: 2379:            strstart++;
    #####: 2380:            lookahead--;
        -: 2381:          } else {
    #####: 2382:            match_available = 1;
    #####: 2383:            strstart++;
    #####: 2384:            lookahead--;
        -: 2385:          }
        -: 2386:        }
        -: 2387:        {
        -: 2388:          {
        -: 2389:            ;
        -: 2390:
    #####: 2391:            { fill_window(); }
        -: 2392:          };
        -: 2393:        }
        -: 2394:      }
    #####: 2395:    while_break: /* CIL Label */;
        -: 2396:    }
        -: 2397:
    #####: 2398:    { tmp___3 = (char *)(&window[(unsigned int)block_start]); }
        -: 2399:
    #####: 2400:    { tmp___4 = flush_block(tmp___3, (ulg)((long)strstart - block_start), 1); }
    #####: 2401:    return (tmp___4);
        -: 2402:  }
        -: 2403:}
        -: 2404:
        -: 2405:long time_stamp;
        -: 2406:
        -: 2407:int zip(int in, int out);
        -: 2408:static ulg crc___0;
    #####: 2409:int zip(int in, int out) {
        -: 2410:
        -: 2411:  ush attr;
        -: 2412:  ush deflate_flags;
        -: 2413:  unsigned int tmp;
        -: 2414:  unsigned int tmp___0;
        -: 2415:  unsigned int tmp___1;
        -: 2416:
        -: 2417:  unsigned int tmp___3;
        -: 2418:  unsigned int tmp___4;
        -: 2419:
        -: 2420:  unsigned int tmp___7;
        -: 2421:  unsigned int tmp___8;
        -: 2422:
        -: 2423:  unsigned int tmp___12;
        -: 2424:
        -: 2425:  unsigned int tmp___16;
        -: 2426:  unsigned int tmp___17;
        -: 2427:
        -: 2428:  unsigned int tmp___20;
        -: 2429:  unsigned int tmp___21;
        -: 2430:
        -: 2431:  unsigned int tmp___24;
        -: 2432:  unsigned int tmp___25;
        -: 2433:
        -: 2434:  unsigned int tmp___28;
        -: 2435:
        -: 2436:  {
        -: 2437:
    #####: 2438:    ofd = out;
        -: 2439:
    #####: 2440:    tmp = outcnt;
    #####: 2441:    outcnt++;
    #####: 2442:    outbuf[tmp] = (uch) * ("\037\213" + 0);
        -: 2443:
    #####: 2444:    tmp___0 = outcnt;
    #####: 2445:    outcnt++;
    #####: 2446:    outbuf[tmp___0] = (uch) * ("\037\213" + 1);
        -: 2447:
    #####: 2448:    tmp___1 = outcnt;
    #####: 2449:    outcnt++;
    #####: 2450:    outbuf[tmp___1] = (uch)8;
        -: 2451:
    #####: 2452:    outcnt++;
        -: 2453:
        -: 2454:    {
    #####: 2455:      tmp___3 = outcnt;
    #####: 2456:      outcnt++;
    #####: 2457:      outbuf[tmp___3] = (uch)((time_stamp & 65535L) & 255L);
    #####: 2458:      tmp___4 = outcnt;
    #####: 2459:      outcnt++;
    #####: 2460:      outbuf[tmp___4] = (uch)((int)((ush)(time_stamp & 65535L)) >> 8);
        -: 2461:    }
        -: 2462:
        -: 2463:    {
    #####: 2464:      tmp___7 = outcnt;
    #####: 2465:      outcnt++;
    #####: 2466:      outbuf[tmp___7] = (uch)(((ulg)time_stamp >> 16) & 255UL);
    #####: 2467:      tmp___8 = outcnt;
    #####: 2468:      outcnt++;
    #####: 2469:      outbuf[tmp___8] = (uch)((int)((ush)((ulg)time_stamp >> 16)) >> 8);
        -: 2470:    }
        -: 2471:
        -: 2472:    {
        -: 2473:
    #####: 2474:      bi_init(out);
    #####: 2475:      ct_init(&attr, &method);
    #####: 2476:      lm_init(level, &deflate_flags);
        -: 2477:
    #####: 2478:      outcnt++;
        -: 2479:    }
        -: 2480:
    #####: 2481:    tmp___12 = outcnt;
    #####: 2482:    outcnt++;
    #####: 2483:    outbuf[tmp___12] = (uch)3;
        -: 2484:
    #####: 2485:    { deflate(); }
        -: 2486:    {
    #####: 2487:      tmp___16 = outcnt;
    #####: 2488:      outcnt++;
    #####: 2489:      outbuf[tmp___16] = (uch)((crc___0 & 65535UL) & 255UL);
    #####: 2490:      tmp___17 = outcnt;
    #####: 2491:      outcnt++;
    #####: 2492:      outbuf[tmp___17] = (uch)((int)((ush)(crc___0 & 65535UL)) >> 8);
        -: 2493:    }
        -: 2494:
        -: 2495:    {
    #####: 2496:      tmp___20 = outcnt;
    #####: 2497:      outcnt++;
    #####: 2498:      outbuf[tmp___20] = (uch)((crc___0 >> 16) & 255UL);
    #####: 2499:      tmp___21 = outcnt;
    #####: 2500:      outcnt++;
    #####: 2501:      outbuf[tmp___21] = (uch)((int)((ush)(crc___0 >> 16)) >> 8);
        -: 2502:    }
        -: 2503:
        -: 2504:    {
    #####: 2505:      tmp___24 = outcnt;
    #####: 2506:      outcnt++;
    #####: 2507:      outbuf[tmp___24] = (uch)((bytes_in & 65535L) & 255L);
    #####: 2508:      tmp___25 = outcnt;
    #####: 2509:      outcnt++;
    #####: 2510:      outbuf[tmp___25] = (uch)((int)((ush)(bytes_in & 65535L)) >> 8);
        -: 2511:    }
        -: 2512:
        -: 2513:    {
    #####: 2514:      tmp___28 = outcnt;
    #####: 2515:      outcnt++;
    #####: 2516:      outbuf[tmp___28] = (uch)(((ulg)bytes_in >> 16) & 255UL);
        -: 2517:
    #####: 2518:      outcnt++;
        -: 2519:    }
        -: 2520:
    #####: 2521:    { flush_outbuf(); }
    #####: 2522:    return (0);
        -: 2523:  }
        -: 2524:}
    #####: 2525:int file_read(char *buf, unsigned int size) {
        -: 2526:  unsigned int len;
        -: 2527:
        -: 2528:  {
    #####: 2529:    { len = (unsigned int)read(ifd, (void *)buf, (size_t)size); }
        -: 2530:
        -: 2531:    {
    #####: 2532:      crc___0 = updcrc((uch *)buf, len);
    #####: 2533:      bytes_in = (long)((ulg)bytes_in + (ulg)len);
        -: 2534:    }
    #####: 2535:    return ((int)len);
        -: 2536:  }
        -: 2537:}
        -: 2538:static char *license_msg[15] = {
        -: 2539:    (char *)"   Copyright (C) 1992-1993 Jean-loup Gailly",
        -: 2540:    (char *)"   This program is free software; you can redistribute it and/or "
        -: 2541:            "modify",
        -: 2542:    (char *)"   it under the terms of the GNU General Public License as "
        -: 2543:            "published by",
        -: 2544:    (char *)"   the Free Software Foundation; either version 2, or (at your "
        -: 2545:            "option)",
        -: 2546:    (char *)"   any later version.",
        -: 2547:    (char *)"",
        -: 2548:    (char
        -: 2549:         *)"   This program is distributed in the hope that it will be useful,",
        -: 2550:    (char *)"   but WITHOUT ANY WARRANTY; without even the implied warranty of",
        -: 2551:    (char *)"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
        -: 2552:    (char *)"   GNU General Public License for more details.",
        -: 2553:    (char *)"",
        -: 2554:    (char *)"   You should have received a copy of the GNU General Public "
        -: 2555:            "License",
        -: 2556:    (char *)"   along with this program; if not, write to the Free Software",
        -: 2557:    (char *)"   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.",
        -: 2558:    (char *)0};
        -: 2559:extern __attribute__((__nothrow__))
        -: 2560:__sighandler_t(__attribute__((__leaf__)) signal)(int __sig,
        -: 2561:                                                 void (*__handler)(int));
        -: 2562:extern __attribute__((__nothrow__)) int(
        -: 2563:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 2564:    stat)(char const *__restrict __file, struct stat *__restrict __buf);
        -: 2565:extern
        -: 2566:    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(2), __leaf__))
        -: 2567:                                     fstat)(int __fd, struct stat *__buf);
        -: 2568:extern __attribute__((__nothrow__)) int(
        -: 2569:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 2570:    lstat)(char const *__restrict __file, struct stat *__restrict __buf);
        -: 2571:extern
        -: 2572:    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
        -: 2573:                                     chmod)(char const *__file,
        -: 2574:                                            __mode_t __mode);
        -: 2575:extern struct _IO_FILE *stdin;
        -: 2576:extern struct _IO_FILE *stdout;
        -: 2577:extern int fflush(FILE *__stream);
        -: 2578:extern int printf(char const *__restrict __format, ...);
        -: 2579:extern char *fgets(char *__restrict __s, int __n, FILE *__restrict __stream);
        -: 2580:extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
        -: 2581:                                        fileno)(FILE *__stream);
        -: 2582:extern __attribute__((__nothrow__)) int(
        -: 2583:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 2584:    memcmp)(void const *__s1, void const *__s2, size_t __n)
        -: 2585:    __attribute__((__pure__));
        -: 2586:extern __attribute__((__nothrow__)) char *(
        -: 2587:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 2588:    strncpy)(char *__restrict __dest, char const *__restrict __src, size_t __n);
        -: 2589:extern __attribute__((__nothrow__)) char *(
        -: 2590:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 2591:    strcat)(char *__restrict __dest, char const *__restrict __src);
        -: 2592:extern __attribute__((__nothrow__)) int(
        -: 2593:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 2594:    strcmp)(char const *__s1, char const *__s2) __attribute__((__pure__));
        -: 2595:extern __attribute__((__nothrow__)) int(
        -: 2596:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 2597:    strncmp)(char const *__s1, char const *__s2, size_t __n)
        -: 2598:    __attribute__((__pure__));
        -: 2599:
        -: 2600:extern int optind;
        -: 2601:extern int getopt_long(int argc, char *const *argv, char const *shortopts,
        -: 2602:                       struct option const *longopts, int *longind);
        -: 2603:extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__))
        -: 2604:                                           ctime)(time_t const *__timer);
        -: 2605:extern int(__attribute__((__nonnull__(1))) open)(char const *__file,
        -: 2606:                                                 int __oflag, ...);
        -: 2607:extern __attribute__((__nothrow__))
        -: 2608:__off_t(__attribute__((__leaf__)) lseek)(int __fd, __off_t __offset,
        -: 2609:                                         int __whence);
        -: 2610:extern int close(int __fd);
        -: 2611:extern
        -: 2612:    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
        -: 2613:                                     chown)(char const *__file, __uid_t __owner,
        -: 2614:                                            __gid_t __group);
        -: 2615:extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
        -: 2616:                                        isatty)(int __fd);
        -: 2617:extern
        -: 2618:    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
        -: 2619:                                     unlink)(char const *__name);
        -: 2620:extern
        -: 2621:    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
        -: 2622:                                     atoi)(char const *__nptr)
        -: 2623:        __attribute__((__pure__));
        -: 2624:extern __attribute__((__nothrow__, __noreturn__)) void(__attribute__((__leaf__))
        -: 2625:                                                       exit)(int __status);
        -: 2626:extern DIR *(__attribute__((__nonnull__(1))) opendir)(char const *__name);
        -: 2627:extern int(__attribute__((__nonnull__(1))) closedir)(DIR *__dirp);
        -: 2628:extern struct dirent *(__attribute__((__nonnull__(1))) readdir)(DIR *__dirp);
        -: 2629:extern
        -: 2630:    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
        -: 2631:                                     utime)(char const *__file,
        -: 2632:                                            struct utimbuf const *__file_times);
        -: 2633:
        -: 2634:int decompress = 0;
        -: 2635:
        -: 2636:int method = 8;
        -: 2637:int level = 6;
        -: 2638:int exit_code = 0;
        -: 2639:
        -: 2640:struct stat istat;
        -: 2641:struct option longopts[24] = {
        -: 2642:    {"ascii", 0, (int *)0, 'a'},      {"to-stdout", 0, (int *)0, 'c'},
        -: 2643:    {"stdout", 0, (int *)0, 'c'},     {"decompress", 0, (int *)0, 'd'},
        -: 2644:    {"uncompress", 0, (int *)0, 'd'}, {"force", 0, (int *)0, 'f'},
        -: 2645:    {"help", 0, (int *)0, 'h'},       {"list", 0, (int *)0, 'l'},
        -: 2646:    {"license", 0, (int *)0, 'L'},    {"no-name", 0, (int *)0, 'n'},
        -: 2647:    {"name", 0, (int *)0, 'N'},       {"quiet", 0, (int *)0, 'q'},
        -: 2648:    {"silent", 0, (int *)0, 'q'},     {"recursive", 0, (int *)0, 'r'},
        -: 2649:    {"suffix", 1, (int *)0, 'S'},     {"test", 0, (int *)0, 't'},
        -: 2650:    {"no-time", 0, (int *)0, 'T'},    {"verbose", 0, (int *)0, 'v'},
        -: 2651:    {"version", 0, (int *)0, 'V'},    {"fast", 0, (int *)0, '1'},
        -: 2652:    {"best", 0, (int *)0, '9'},       {"lzw", 0, (int *)0, 'Z'},
        -: 2653:    {"bits", 1, (int *)0, 'b'},       {(char const *)0, 0, (int *)0, 0}};
        -: 2654:static void usage(void);
        -: 2655:static void help(void);
        -: 2656:static void license(void);
        -: 2657:static void version(void);
        -: 2658:static void treat_stdin(void);
        -: 2659:static void treat_file(char *iname);
        -: 2660:static int create_outfile(void);
        -: 2661:static int do_stat(char *name, struct stat *sbuf);
        -: 2662:static char *get_suffix(char *name);
        -: 2663:static int get_istat(char *iname, struct stat *sbuf);
        -: 2664:static int make_ofname(void);
        -: 2665:static int same_file(struct stat *stat1, struct stat *stat2);
        -: 2666:static int name_too_long(char *name, struct stat *statb);
        -: 2667:static void shorten_name(char *name);
        -: 2668:static int get_method(int in);
        -: 2669:static void do_list(int ifd___0, int method___0);
        -: 2670:static int check_ofname(void);
        -: 2671:static void copy_stat(struct stat *ifstat);
        -: 2672:static void do_exit(int exitcode);
        -: 2673:int main(int argc, char **argv);
        -: 2674:int (*work)(int infile, int outfile) = &zip;
        -: 2675:static void treat_dir(char *dir);
        -: 2676:static void reset_times(char *name, struct stat *statb);
        -: 2677:
        -: 2678:static char *help_msg[18] = {
        -: 2679:    (char *)" -c --stdout      write on standard output, keep original files "
        -: 2680:            "unchanged",
        -: 2681:    (char *)" -d --decompress  decompress",
        -: 2682:    (char *)" -f --force       force overwrite of output file and compress "
        -: 2683:            "links",
        -: 2684:    (char *)" -h --help        give this help",
        -: 2685:    (char *)" -l --list        list compressed file contents",
        -: 2686:    (char *)" -L --license     display software license",
        -: 2687:    (char *)" -n --no-name     do not save or restore the original name and "
        -: 2688:            "time stamp",
        -: 2689:    (char
        -: 2690:         *)" -N --name        save or restore the original name and time stamp",
        -: 2691:    (char *)" -q --quiet       suppress all warnings",
        -: 2692:    (char *)" -r --recursive   operate recursively on directories",
        -: 2693:    (char *)" -S .suf  --suffix .suf     use suffix .suf on compressed files",
        -: 2694:    (char *)" -t --test        test compressed file integrity",
        -: 2695:    (char *)" -v --verbose     verbose mode",
        -: 2696:    (char *)" -V --version     display version number",
        -: 2697:    (char *)" -1 --fast        compress faster",
        -: 2698:    (char *)" -9 --best        compress better",
        -: 2699:    (char *)" file...          files to (de)compress. If none given, use "
        -: 2700:            "standard input.",
        -: 2701:    (char *)0};
    #####: 2702:static void help(void) {
        -: 2703:  char **p;
        -: 2704:  char **tmp;
        -: 2705:
        -: 2706:  {
    #####: 2707:    { p = help_msg; }
        -: 2708:    {
        -: 2709:      while (1) {
        -: 2710:        ;
    #####: 2711:        if (!*p) {
    #####: 2712:          goto while_break;
        -: 2713:        }
        -: 2714:        {
    #####: 2715:          tmp = p;
    #####: 2716:          p++;
    #####: 2717:          fprintf((FILE * /* __restrict  */) stderr,
        -: 2718:                  (char const * /* __restrict  */) "%s\n", *tmp);
        -: 2719:        }
        -: 2720:      }
    #####: 2721:    while_break: /* CIL Label */;
        -: 2722:    }
        -: 2723:  }
    #####: 2724:}
    #####: 2725:static void license(void) {
        -: 2726:  char **p;
        -: 2727:  char **tmp;
        -: 2728:
        -: 2729:  {
    #####: 2730:    { p = license_msg; }
        -: 2731:    {
        -: 2732:      while (1) {
        -: 2733:        ;
    #####: 2734:        if (!*p) {
    #####: 2735:          goto while_break;
        -: 2736:        }
        -: 2737:        {
    #####: 2738:          tmp = p;
    #####: 2739:          p++;
    #####: 2740:          fprintf((FILE * /* __restrict  */) stderr,
        -: 2741:                  (char const * /* __restrict  */) "%s\n", *tmp);
        -: 2742:        }
        -: 2743:      }
    #####: 2744:    while_break: /* CIL Label */;
        -: 2745:    }
        -: 2746:  }
    #####: 2747:}
    #####: 2748:static void version(void) {
        -: 2749:
    #####: 2750:  fprintf((FILE * /* __restrict  */) stderr,
        -: 2751:          (char const * /* __restrict  */) "%s %s (%s)\n", progname, "1.2.4",
        -: 2752:          "18 Aug 93");
    #####: 2753:  fprintf((FILE * /* __restrict  */) stderr,
        -: 2754:          (char const * /* __restrict  */) "Compilation options:\n%s %s ",
        -: 2755:          "DIRENT", "UTIME");
    #####: 2756:  fprintf((FILE * /* __restrict  */) stderr,
        -: 2757:          (char const * /* __restrict  */) "STDC_HEADERS ");
    #####: 2758:  fprintf((FILE * /* __restrict  */) stderr,
        -: 2759:          (char const * /* __restrict  */) "HAVE_UNISTD_H ");
    #####: 2760:  fprintf((FILE * /* __restrict  */) stderr,
        -: 2761:          (char const * /* __restrict  */) "\n");
    #####: 2762:}
    #####: 2763:int main(int argc, char **argv) {
        -: 2764:  int file_count;
        -: 2765:
        -: 2766:  int optc;
        -: 2767:
        -: 2768:  int tmp___8;
        -: 2769:
        -: 2770:  {
    #####: 2771:    { progname = basename(*(argv + 0)); }
        -: 2772:
        -: 2773:    {
        -: 2774:      {
        -: 2775:        ;
        -: 2776:        {
    #####: 2777:          optc = getopt_long(argc, (char *const *)argv,
        -: 2778:                             "ab:cdfhH?lLmMnNqrS:tvVZ123456789",
        -: 2779:                             (struct option const *)(longopts), (int *)0);
        -: 2780:        }
        -: 2781:
        -: 2782:        {
        -: 2783:
    #####: 2784:          if (optc == 100) {
    #####: 2785:            goto case_100;
        -: 2786:          }
        -: 2787:
    #####: 2788:          if (optc == 104) {
    #####: 2789:            goto case_104;
        -: 2790:          }
        -: 2791:
    #####: 2792:          if (optc == 63) {
    #####: 2793:            goto case_104;
        -: 2794:          }
        -: 2795:
    #####: 2796:          if (optc == 76) {
    #####: 2797:            goto case_76;
        -: 2798:          }
        -: 2799:
    #####: 2800:          if (optc == 86) {
    #####: 2801:            goto case_86;
        -: 2802:          }
        -: 2803:
    #####: 2804:          goto switch_break;
    #####: 2805:        case_100: /* CIL Label */
    #####: 2806:          decompress = 1;
    #####: 2807:          goto switch_break;
        -: 2808:
    #####: 2809:        case_104 : /* CIL Label */
        -: 2810:
        -: 2811:        {
    #####: 2812:          help();
    #####: 2813:          do_exit(0);
        -: 2814:        }
        -: 2815:
    #####: 2816:        case_76 : /* CIL Label */
        -: 2817:        {
    #####: 2818:          license();
    #####: 2819:          do_exit(0);
        -: 2820:        }
        -: 2821:
    #####: 2822:        case_86 : /* CIL Label */
        -: 2823:        {
    #####: 2824:          version();
        -: 2825:        }
        -: 2826:
    #####: 2827:        switch_break: /* CIL Label */;
        -: 2828:        }
        -: 2829:      };
        -: 2830:    }
        -: 2831:
    #####: 2832:    file_count = argc - optind;
        -: 2833:
    #####: 2834:    if (file_count != 0) {
        -: 2835:
        -: 2836:      {
        -: 2837:        ;
        -: 2838:
        -: 2839:        {
    #####: 2840:          tmp___8 = optind;
        -: 2841:
    #####: 2842:          treat_file(*(argv + tmp___8));
        -: 2843:        }
        -: 2844:      };
        -: 2845:
        -: 2846:    } else {
    #####: 2847:      treat_stdin();
        -: 2848:    }
        -: 2849:
    #####: 2850:    return (exit_code);
        -: 2851:  }
        -: 2852:}
    #####: 2853:static void treat_stdin(void) {
        -: 2854:  char const *tmp;
        -: 2855:  char const *tmp___0;
        -: 2856:  struct _IO_FILE *tmp___1;
        -: 2857:  int tmp___2;
        -: 2858:  int tmp___3;
        -: 2859:
        -: 2860:  int tmp___6;
        -: 2861:  int tmp___7;
        -: 2862:  int tmp___8;
        -: 2863:  int tmp___9;
        -: 2864:  int tmp___10;
        -: 2865:
        -: 2866:  {
        -: 2867:    {
        -: 2868:
    #####: 2869:      { tmp___1 = stdout; }
        -: 2870:      {
    #####: 2871:        tmp___2 = fileno(tmp___1);
    #####: 2872:        tmp___3 = isatty(tmp___2);
        -: 2873:      }
    #####: 2874:      if (tmp___3) {
        -: 2875:
        -: 2876:        {
    #####: 2877:          tmp = "";
        -: 2878:        }
        -: 2879:
    #####: 2880:        { tmp___0 = "written to"; }
        -: 2881:        {
    #####: 2882:          fprintf((FILE * /* __restrict  */) stderr,
        -: 2883:                  (char const * /* __restrict  */) "%s: compressed data not "
        -: 2884:                                                   "%s a terminal. Use -f to "
        -: 2885:                                                   "force %scompression.\n",
        -: 2886:                  progname, tmp___0, tmp);
    #####: 2887:          fprintf((FILE * /* __restrict  */) stderr,
        -: 2888:                  (char const * /* __restrict  */) "For help, type: %s -h\n",
        -: 2889:                  progname);
    #####: 2890:          do_exit(1);
        -: 2891:        }
        -: 2892:      }
        -: 2893:    }
        -: 2894:
        -: 2895:    {
        -: 2896:
        -: 2897:      {
    #####: 2898:        tmp___6 = fileno(stdin);
    #####: 2899:        tmp___7 = fstat(tmp___6, &istat);
        -: 2900:      }
        -: 2901:
    #####: 2902:      time_stamp = istat.st_mtim.tv_sec;
        -: 2903:    }
        -: 2904:
    #####: 2905:    if (decompress) {
        -: 2906:
    #####: 2907:      method = get_method(ifd);
        -: 2908:    }
        -: 2909:
        -: 2910:    {
        -: 2911:      {
        -: 2912:        ;
        -: 2913:        {
    #####: 2914:          tmp___8 = fileno(stdout);
    #####: 2915:          tmp___9 = fileno(stdin);
    #####: 2916:          tmp___10 = (*work)(tmp___9, tmp___8);
        -: 2917:        }
        -: 2918:      };
        -: 2919:    }
        -: 2920:  }
    #####: 2921:}
    #####: 2922:static void treat_file(char *iname) {
        -: 2923:
        -: 2924:  int tmp___0;
        -: 2925:
        -: 2926:  int tmp___3;
        -: 2927:
        -: 2928:  int tmp___11;
        -: 2929:
        -: 2930:  {
        -: 2931:
    #####: 2932:    { tmp___0 = get_istat(iname, &istat); }
        -: 2933:
    #####: 2934:    { tmp___3 = 0; }
        -: 2935:
    #####: 2936:    { ifd = open((char const *)(ifname), tmp___3, 384); }
        -: 2937:
        -: 2938:    {
    #####: 2939:      { method = get_method(ifd); }
    #####: 2940:      if (method < 0) {
        -: 2941:
    #####: 2942:        return;
        -: 2943:      }
        -: 2944:    }
        -: 2945:
        -: 2946:    {
        -: 2947:      {
        -: 2948:        ;
    #####: 2949:        { tmp___11 = (*work)(ifd, ofd); }
        -: 2950:      };
        -: 2951:    }
        -: 2952:  }
        -: 2953:}
        -: 2954:
    #####: 2955:static int get_istat(char *iname, struct stat *sbuf) {
        -: 2956:
        -: 2957:  {
        -: 2958:
    #####: 2959:    strcpy((char * /* __restrict  */)(ifname),
        -: 2960:           (char const * /* __restrict  */)iname);
        -: 2961:  }
    #####: 2962:  { return (0); }
        -: 2963:}
        -: 2964:
    #####: 2965:static int get_method(int in) {
        -: 2966:
        -: 2967:  int tmp___6;
        -: 2968:
        -: 2969:  unsigned int tmp___11;
        -: 2970:
        -: 2971:  int tmp___13;
        -: 2972:
        -: 2973:  {
        -: 2974:
        -: 2975:    {
        -: 2976:
        -: 2977:        {
        -: 2978:
    #####: 2979:            tmp___6 = fill_inbuf(0);
        -: 2980:  }
        -: 2981:
    #####: 2982:  { inptr++; }
        -: 2983:}
        -: 2984:
        -: 2985:{
        -: 2986:
        -: 2987:  {
    #####: 2988:    tmp___11 = inptr;
    #####: 2989:    inptr++;
    #####: 2990:    tmp___13 = (int)inbuf[tmp___11];
        -: 2991:  }
        -: 2992:
    #####: 2993:  method = tmp___13;
    #####: 2994:  if (method != 8) {
        -: 2995:    {
        -: 2996:
    #####: 2997:      exit_code = 1;
        -: 2998:    }
    #####: 2999:    return (-1);
        -: 3000:  }
    #####: 3001:  work = &unzip;
    #####: 3002:  { inptr++; }
        -: 3003:
    #####: 3004:  { inptr++; }
        -: 3005:
    #####: 3006:  { inptr++; }
        -: 3007:
    #####: 3008:  { inptr++; }
        -: 3009:
    #####: 3010:  { inptr++; }
        -: 3011:
    #####: 3012:  { inptr++; }
        -: 3013:
    #####: 3014:  { inptr++; }
        -: 3015:}
        -: 3016:}
    #####: 3017:}
        -: 3018:
    #####: 3019:static void do_exit(int exitcode) { exit(exitcode); }
