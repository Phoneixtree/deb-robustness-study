        -:    0:Source:gzip-1.2.4.c.reduced.c
        -:    0:Graph:gzip-1.2.4.c.reduced.gcno
        -:    0:Data:gzip-1.2.4.c.reduced.gcda
        -:    0:Runs:1
        -:    1:typedef void *voidp;
        -:    2:typedef unsigned char uch;
        -:    3:typedef unsigned short ush;
        -:    4:typedef unsigned long ulg;
        -:    5:typedef long __off_t;
        -:    6:typedef long __off64_t;
        -:    7:typedef long __ssize_t;
        -:    8:typedef __ssize_t ssize_t;
        -:    9:typedef unsigned long size_t;
        -:   10:struct _IO_FILE;
        -:   11:struct _IO_FILE;
        -:   12:typedef struct _IO_FILE FILE;
        -:   13:typedef void _IO_lock_t;
        -:   14:struct _IO_marker {
        -:   15:  struct _IO_marker *_next;
        -:   16:  struct _IO_FILE *_sbuf;
        -:   17:  int _pos;
        -:   18:};
        -:   19:struct _IO_FILE {
        -:   20:  int _flags;
        -:   21:  char *_IO_read_ptr;
        -:   22:  char *_IO_read_end;
        -:   23:  char *_IO_read_base;
        -:   24:  char *_IO_write_base;
        -:   25:  char *_IO_write_ptr;
        -:   26:  char *_IO_write_end;
        -:   27:  char *_IO_buf_base;
        -:   28:  char *_IO_buf_end;
        -:   29:  char *_IO_save_base;
        -:   30:  char *_IO_backup_base;
        -:   31:  char *_IO_save_end;
        -:   32:  struct _IO_marker *_markers;
        -:   33:  struct _IO_FILE *_chain;
        -:   34:  int _fileno;
        -:   35:  int _flags2;
        -:   36:  __off_t _old_offset;
        -:   37:  unsigned short _cur_column;
        -:   38:  signed char _vtable_offset;
        -:   39:  char _shortbuf[1];
        -:   40:  _IO_lock_t *_lock;
        -:   41:  __off64_t _offset;
        -:   42:  void *__pad1;
        -:   43:  void *__pad2;
        -:   44:  void *__pad3;
        -:   45:  void *__pad4;
        -:   46:  size_t __pad5;
        -:   47:  int _mode;
        -:   48:  char _unused2[(15UL * sizeof(int) - 4UL * sizeof(void *)) - sizeof(size_t)];
        -:   49:};
        -:   50:typedef unsigned char char_type;
        -:   51:typedef long code_int;
        -:   52:typedef unsigned long cmp_code_int;
        -:   53:typedef struct _IO_FILE _IO_FILE;
        -:   54:struct huft;
        -:   55:union __anonunion_v_25 {
        -:   56:  ush n;
        -:   57:  struct huft *t;
        -:   58:};
        -:   59:struct huft {
        -:   60:  uch e;
        -:   61:  uch b;
        -:   62:  union __anonunion_v_25 v;
        -:   63:};
        -:   64:typedef int file_t;
        -:   65:union __anonunion_fc_7 {
        -:   66:  ush freq;
        -:   67:  ush code;
        -:   68:};
        -:   69:union __anonunion_dl_8 {
        -:   70:  ush dad;
        -:   71:  ush len;
        -:   72:};
        -:   73:struct ct_data {
        -:   74:  union __anonunion_fc_7 fc;
        -:   75:  union __anonunion_dl_8 dl;
        -:   76:};
        -:   77:typedef struct ct_data ct_data;
        -:   78:struct tree_desc {
        -:   79:  ct_data *dyn_tree;
        -:   80:  ct_data *static_tree;
        -:   81:  int *extra_bits;
        -:   82:  int extra_base;
        -:   83:  int elems;
        -:   84:  int max_length;
        -:   85:  int max_code;
        -:   86:};
        -:   87:typedef struct tree_desc tree_desc;
        -:   88:typedef ush Pos;
        -:   89:typedef unsigned int IPos;
        -:   90:struct config {
        -:   91:  ush good_length;
        -:   92:  ush max_lazy;
        -:   93:  ush nice_length;
        -:   94:  ush max_chain;
        -:   95:};
        -:   96:typedef struct config config;
        -:   97:typedef unsigned long __dev_t;
        -:   98:typedef unsigned int __uid_t;
        -:   99:typedef unsigned int __gid_t;
        -:  100:typedef unsigned long __ino_t;
        -:  101:typedef unsigned int __mode_t;
        -:  102:typedef unsigned long __nlink_t;
        -:  103:typedef long __time_t;
        -:  104:typedef long __blksize_t;
        -:  105:typedef long __blkcnt_t;
        -:  106:typedef long __syscall_slong_t;
        -:  107:typedef __off_t off_t;
        -:  108:typedef __time_t time_t;
        -:  109:struct timespec {
        -:  110:  __time_t tv_sec;
        -:  111:  __syscall_slong_t tv_nsec;
        -:  112:};
        -:  113:typedef void (*__sighandler_t)(int);
        -:  114:struct stat {
        -:  115:  __dev_t st_dev;
        -:  116:  __ino_t st_ino;
        -:  117:  __nlink_t st_nlink;
        -:  118:  __mode_t st_mode;
        -:  119:  __uid_t st_uid;
        -:  120:  __gid_t st_gid;
        -:  121:  int __pad0;
        -:  122:  __dev_t st_rdev;
        -:  123:  __off_t st_size;
        -:  124:  __blksize_t st_blksize;
        -:  125:  __blkcnt_t st_blocks;
        -:  126:  struct timespec st_atim;
        -:  127:  struct timespec st_mtim;
        -:  128:  struct timespec st_ctim;
        -:  129:  __syscall_slong_t __glibc_reserved[3];
        -:  130:};
        -:  131:struct option {
        -:  132:  char const *name;
        -:  133:  int has_arg;
        -:  134:  int *flag;
        -:  135:  int val;
        -:  136:};
        -:  137:struct dirent {
        -:  138:  __ino_t d_ino;
        -:  139:  __off_t d_off;
        -:  140:  unsigned short d_reclen;
        -:  141:  unsigned char d_type;
        -:  142:  char d_name[256];
        -:  143:};
        -:  144:struct __dirstream;
        -:  145:struct __dirstream;
        -:  146:typedef struct __dirstream DIR;
        -:  147:typedef struct dirent dir_type;
        -:  148:struct utimbuf {
        -:  149:  __time_t actime;
        -:  150:  __time_t modtime;
        -:  151:};
        -:  152:uch inbuf[32832];
        -:  153:uch outbuf[18432];
        -:  154:ush d_buf[32768];
        -:  155:uch window[65536L];
        -:  156:ush prev[1L << 16];
        -:  157:unsigned int insize;
        -:  158:unsigned int inptr;
        -:  159:int ifd;
        -:  160:int ofd;
        -:  161:
        -:  162:int unlzh(int in, int out);
        -:  163:int fill_inbuf(int eof_ok);
        -:  164:void write_buf(int fd, voidp buf, unsigned int cnt);
        -:  165:void error(char *m);
        -:  166:static unsigned int decode(unsigned int count, uch *buffer);
        -:  167:static void decode_start(void);
        -:  168:static void huf_decode_start(void);
        -:  169:static unsigned int decode_c(void);
        -:  170:static unsigned int decode_p(void);
        -:  171:static void read_pt_len(int nn, int nbit, int i_special);
        -:  172:static void read_c_len(void);
        -:  173:static void fillbuf(int n);
        -:  174:static unsigned int getbits(int n);
        -:  175:static void init_getbits(void);
        -:  176:static void make_table(int nchar, uch *bitlen, int tablebits, ush *table);
        -:  177:
        -:  178:unsigned int outcnt;
        -:  179:
        -:  180:int unpack(int in, int out);
        -:  181:void flush_window(void);
        -:  182:
        -:  183:static void read_tree(void);
        -:  184:static void build_tree(void);
        -:  185:
        -:  186:extern ssize_t read(int __fd, void *__buf, size_t __nbytes);
        -:  187:extern struct _IO_FILE *stderr;
        -:  188:extern int fprintf(FILE *__restrict __stream, char const *__restrict __format,
        -:  189:                   ...);
        -:  190:extern __attribute__((__nothrow__)) void *(
        -:  191:    __attribute__((__nonnull__(1, 2), __leaf__))
        -:  192:    memcpy)(void *__restrict __dest, void const *__restrict __src, size_t __n);
        -:  193:extern
        -:  194:    __attribute__((__nothrow__)) void *(__attribute__((__nonnull__(1),
        -:  195:                                                       __leaf__))
        -:  196:                                        memset)(void *__s, int __c, size_t __n);
        -:  197:long bytes_in;
        -:  198:char ifname[1024];
        -:  199:char *progname;
        -:  200:
        -:  201:void read_error(void);
        -:  202:
        -:  203:int unlzw(int in, int out);
        -:  204:
        -:  205:int lzw(int in, int out);
        -:  206:
        -:  207:extern __attribute__((__nothrow__)) unsigned short const **(
        -:  208:    __attribute__((__leaf__)) __ctype_b_loc)(void)__attribute__((__const__));
        -:  209:extern __attribute__((__nothrow__)) int *(
        -:  210:    __attribute__((__leaf__)) __errno_location)(void)__attribute__((__const__));
        -:  211:extern ssize_t write(int __fd, void const *__buf, size_t __n);
        -:  212:extern __attribute__((__nothrow__)) void *(__attribute__((__leaf__))
        -:  213:                                           malloc)(size_t __size)
        -:  214:    __attribute__((__malloc__));
        -:  215:extern
        -:  216:    __attribute__((__nothrow__)) void *(__attribute__((__leaf__))
        -:  217:                                        calloc)(size_t __nmemb, size_t __size)
        -:  218:        __attribute__((__malloc__));
        -:  219:extern __attribute__((__nothrow__)) void(__attribute__((__leaf__))
        -:  220:                                         free)(void *__ptr);
        -:  221:extern __attribute__((__nothrow__)) char *(__attribute__((__nonnull__(1),
        -:  222:                                                          __leaf__))
        -:  223:                                           getenv)(char const *__name);
        -:  224:extern int _IO_putc(int __c, _IO_FILE *__fp);
        -:  225:extern void perror(char const *__s);
        -:  226:extern __attribute__((__nothrow__)) char *(
        -:  227:    __attribute__((__nonnull__(1, 2), __leaf__))
        -:  228:    strcpy)(char *__restrict __dest, char const *__restrict __src);
        -:  229:extern __attribute__((__nothrow__)) char *(__attribute__((__nonnull__(1),
        -:  230:                                                          __leaf__))
        -:  231:                                           strrchr)(char const *__s, int __c)
        -:  232:    __attribute__((__pure__));
        -:  233:extern __attribute__((__nothrow__))
        -:  234:size_t(__attribute__((__nonnull__(1, 2), __leaf__))
        -:  235:       strcspn)(char const *__s, char const *__reject)
        -:  236:    __attribute__((__pure__));
        -:  237:extern __attribute__((__nothrow__))
        -:  238:size_t(__attribute__((__nonnull__(1, 2), __leaf__))
        -:  239:       strspn)(char const *__s, char const *__accept) __attribute__((__pure__));
        -:  240:extern __attribute__((__nothrow__))
        -:  241:size_t(__attribute__((__nonnull__(1), __leaf__)) strlen)(char const *__s)
        -:  242:    __attribute__((__pure__));
        -:  243:char ofname[1024];
        -:  244:void abort_gzip(void);
        -:  245:int copy(int in, int out);
        -:  246:ulg updcrc(uch *s, unsigned int n);
        -:  247:void clear_bufs(void);
        -:  248:void flush_outbuf(void);
        -:  249:char *strlwr(char *s);
        -:  250:char *basename(char *fname);
        -:  251:char *add_envopt(int *argcp, char ***argvp, char *env___0);
        -:  252:void write_error(void);
        -:  253:void display_ratio(long num, long den, FILE *file);
        -:  254:voidp xmalloc(unsigned int size);
        -:  255:ulg crc_32_tab[256];
        -:  256:
        -:  257:static ulg crc = (ulg)4294967295L;
    #####:  258:ulg updcrc(uch *s, unsigned int n) {
        -:  259:  register ulg c;
        -:  260:  uch *tmp;
        -:  261:
        -:  262:  {
        -:  263:
        -:  264:    {
    #####:  265:      c = crc;
    #####:  266:      if (n) {
        -:  267:
        -:  268:        while (1) {
        -:  269:          ;
    #####:  270:          tmp = s;
    #####:  271:          s++;
    #####:  272:          c = crc_32_tab[((int)c ^ (int)*tmp) & 255] ^ (c >> 8);
    #####:  273:          n--;
    #####:  274:          if (!n) {
    #####:  275:            goto while_break;
        -:  276:          }
        -:  277:        }
    #####:  278:      while_break: /* CIL Label */;
        -:  279:      }
        -:  280:    }
    #####:  281:    crc = c;
    #####:  282:    return (c ^ 4294967295UL);
        -:  283:  }
        -:  284:}
        -:  285:
    #####:  286:int fill_inbuf(int eof_ok) {
        -:  287:  int len;
        -:  288:
        -:  289:  {
    #####:  290:    { insize = 0U; }
        -:  291:    {
        -:  292:      {
        -:  293:        ;
        -:  294:        {
    #####:  295:          len = (int)read(ifd, (void *)((char *)(inbuf) + insize),
    #####:  296:                          (size_t)(32768U - insize));
        -:  297:        }
        -:  298:
    #####:  299:        insize += (unsigned int)len;
        -:  300:      };
        -:  301:    }
        -:  302:
    #####:  303:    inptr = 1U;
    #####:  304:    return ((int)inbuf[0]);
        -:  305:  }
        -:  306:}
    #####:  307:void flush_outbuf(void) {
        -:  308:
    #####:  309:  write_buf(ofd, (voidp)((char *)(outbuf)), outcnt);
        -:  310:
    #####:  311:  outcnt = 0U;
    #####:  312:}
    #####:  313:void flush_window(void) { write_buf(ofd, (voidp)((char *)(window)), outcnt); }
    #####:  314:void write_buf(int fd, voidp buf, unsigned int cnt) {
        -:  315:  unsigned int n;
        -:  316:
        -:  317:  {
        -:  318:
        -:  319:    {
        -:  320:      ;
    #####:  321:      { n = (unsigned int)write(fd, (void const *)buf, (size_t)cnt); }
        -:  322:
    #####:  323:      { write_error(); }
        -:  324:    };
        -:  325:  }
    #####:  326:}
        -:  327:
        1:  328:char *basename(char *fname) {
        -:  329:  char *p;
        -:  330:
        -:  331:  {
        1:  332:    { p = strrchr((char const *)fname, '/'); }
        1:  333:    { fname = p + 1; }
        1:  334:    return (fname);
        -:  335:  }
        -:  336:}
        -:  337:
    #####:  338:void error(char *m) {
        -:  339:
    #####:  340:  fprintf((FILE * /* __restrict  */) stderr,
        -:  341:          (char const * /* __restrict  */) "\n%s: %s: %s\n", progname, ifname,
        -:  342:          m);
    #####:  343:}
        -:  344:
    #####:  345:void write_error(void) { perror((char const *)(ofname)); }
        -:  346:
        -:  347:ulg crc_32_tab[256] = {
        -:  348:    (ulg)0L,          (ulg)1996959894L, (ulg)3993919788L, (ulg)2567524794L,
        -:  349:    (ulg)124634137L,  (ulg)1886057615L, (ulg)3915621685L, (ulg)2657392035L,
        -:  350:    (ulg)249268274L,  (ulg)2044508324L, (ulg)3772115230L, (ulg)2547177864L,
        -:  351:    (ulg)162941995L,  (ulg)2125561021L, (ulg)3887607047L, (ulg)2428444049L,
        -:  352:    (ulg)498536548L,  (ulg)1789927666L, (ulg)4089016648L, (ulg)2227061214L,
        -:  353:    (ulg)450548861L,  (ulg)1843258603L, (ulg)4107580753L, (ulg)2211677639L,
        -:  354:    (ulg)325883990L,  (ulg)1684777152L, (ulg)4251122042L, (ulg)2321926636L,
        -:  355:    (ulg)335633487L,  (ulg)1661365465L, (ulg)4195302755L, (ulg)2366115317L,
        -:  356:    (ulg)997073096L,  (ulg)1281953886L, (ulg)3579855332L, (ulg)2724688242L,
        -:  357:    (ulg)1006888145L, (ulg)1258607687L, (ulg)3524101629L, (ulg)2768942443L,
        -:  358:    (ulg)901097722L,  (ulg)1119000684L, (ulg)3686517206L, (ulg)2898065728L,
        -:  359:    (ulg)853044451L,  (ulg)1172266101L, (ulg)3705015759L, (ulg)2882616665L,
        -:  360:    (ulg)651767980L,  (ulg)1373503546L, (ulg)3369554304L, (ulg)3218104598L,
        -:  361:    (ulg)565507253L,  (ulg)1454621731L, (ulg)3485111705L, (ulg)3099436303L,
        -:  362:    (ulg)671266974L,  (ulg)1594198024L, (ulg)3322730930L, (ulg)2970347812L,
        -:  363:    (ulg)795835527L,  (ulg)1483230225L, (ulg)3244367275L, (ulg)3060149565L,
        -:  364:    (ulg)1994146192L, (ulg)31158534L,   (ulg)2563907772L, (ulg)4023717930L,
        -:  365:    (ulg)1907459465L, (ulg)112637215L,  (ulg)2680153253L, (ulg)3904427059L,
        -:  366:    (ulg)2013776290L, (ulg)251722036L,  (ulg)2517215374L, (ulg)3775830040L,
        -:  367:    (ulg)2137656763L, (ulg)141376813L,  (ulg)2439277719L, (ulg)3865271297L,
        -:  368:    (ulg)1802195444L, (ulg)476864866L,  (ulg)2238001368L, (ulg)4066508878L,
        -:  369:    (ulg)1812370925L, (ulg)453092731L,  (ulg)2181625025L, (ulg)4111451223L,
        -:  370:    (ulg)1706088902L, (ulg)314042704L,  (ulg)2344532202L, (ulg)4240017532L,
        -:  371:    (ulg)1658658271L, (ulg)366619977L,  (ulg)2362670323L, (ulg)4224994405L,
        -:  372:    (ulg)1303535960L, (ulg)984961486L,  (ulg)2747007092L, (ulg)3569037538L,
        -:  373:    (ulg)1256170817L, (ulg)1037604311L, (ulg)2765210733L, (ulg)3554079995L,
        -:  374:    (ulg)1131014506L, (ulg)879679996L,  (ulg)2909243462L, (ulg)3663771856L,
        -:  375:    (ulg)1141124467L, (ulg)855842277L,  (ulg)2852801631L, (ulg)3708648649L,
        -:  376:    (ulg)1342533948L, (ulg)654459306L,  (ulg)3188396048L, (ulg)3373015174L,
        -:  377:    (ulg)1466479909L, (ulg)544179635L,  (ulg)3110523913L, (ulg)3462522015L,
        -:  378:    (ulg)1591671054L, (ulg)702138776L,  (ulg)2966460450L, (ulg)3352799412L,
        -:  379:    (ulg)1504918807L, (ulg)783551873L,  (ulg)3082640443L, (ulg)3233442989L,
        -:  380:    (ulg)3988292384L, (ulg)2596254646L, (ulg)62317068L,   (ulg)1957810842L,
        -:  381:    (ulg)3939845945L, (ulg)2647816111L, (ulg)81470997L,   (ulg)1943803523L,
        -:  382:    (ulg)3814918930L, (ulg)2489596804L, (ulg)225274430L,  (ulg)2053790376L,
        -:  383:    (ulg)3826175755L, (ulg)2466906013L, (ulg)167816743L,  (ulg)2097651377L,
        -:  384:    (ulg)4027552580L, (ulg)2265490386L, (ulg)503444072L,  (ulg)1762050814L,
        -:  385:    (ulg)4150417245L, (ulg)2154129355L, (ulg)426522225L,  (ulg)1852507879L,
        -:  386:    (ulg)4275313526L, (ulg)2312317920L, (ulg)282753626L,  (ulg)1742555852L,
        -:  387:    (ulg)4189708143L, (ulg)2394877945L, (ulg)397917763L,  (ulg)1622183637L,
        -:  388:    (ulg)3604390888L, (ulg)2714866558L, (ulg)953729732L,  (ulg)1340076626L,
        -:  389:    (ulg)3518719985L, (ulg)2797360999L, (ulg)1068828381L, (ulg)1219638859L,
        -:  390:    (ulg)3624741850L, (ulg)2936675148L, (ulg)906185462L,  (ulg)1090812512L,
        -:  391:    (ulg)3747672003L, (ulg)2825379669L, (ulg)829329135L,  (ulg)1181335161L,
        -:  392:    (ulg)3412177804L, (ulg)3160834842L, (ulg)628085408L,  (ulg)1382605366L,
        -:  393:    (ulg)3423369109L, (ulg)3138078467L, (ulg)570562233L,  (ulg)1426400815L,
        -:  394:    (ulg)3317316542L, (ulg)2998733608L, (ulg)733239954L,  (ulg)1555261956L,
        -:  395:    (ulg)3268935591L, (ulg)3050360625L, (ulg)752459403L,  (ulg)1541320221L,
        -:  396:    (ulg)2607071920L, (ulg)3965973030L, (ulg)1969922972L, (ulg)40735498L,
        -:  397:    (ulg)2617837225L, (ulg)3943577151L, (ulg)1913087877L, (ulg)83908371L,
        -:  398:    (ulg)2512341634L, (ulg)3803740692L, (ulg)2075208622L, (ulg)213261112L,
        -:  399:    (ulg)2463272603L, (ulg)3855990285L, (ulg)2094854071L, (ulg)198958881L,
        -:  400:    (ulg)2262029012L, (ulg)4057260610L, (ulg)1759359992L, (ulg)534414190L,
        -:  401:    (ulg)2176718541L, (ulg)4139329115L, (ulg)1873836001L, (ulg)414664567L,
        -:  402:    (ulg)2282248934L, (ulg)4279200368L, (ulg)1711684554L, (ulg)285281116L,
        -:  403:    (ulg)2405801727L, (ulg)4167216745L, (ulg)1634467795L, (ulg)376229701L,
        -:  404:    (ulg)2685067896L, (ulg)3608007406L, (ulg)1308918612L, (ulg)956543938L,
        -:  405:    (ulg)2808555105L, (ulg)3495958263L, (ulg)1231636301L, (ulg)1047427035L,
        -:  406:    (ulg)2932959818L, (ulg)3654703836L, (ulg)1088359270L, (ulg)936918000L,
        -:  407:    (ulg)2847714899L, (ulg)3736837829L, (ulg)1202900863L, (ulg)817233897L,
        -:  408:    (ulg)3183342108L, (ulg)3401237130L, (ulg)1404277552L, (ulg)615818150L,
        -:  409:    (ulg)3134207493L, (ulg)3453421203L, (ulg)1423857449L, (ulg)601450431L,
        -:  410:    (ulg)3009837614L, (ulg)3294710456L, (ulg)1567103746L, (ulg)711928724L,
        -:  411:    (ulg)3020668471L, (ulg)3272380065L, (ulg)1510334235L, (ulg)755167117L};
        -:  412:int inflate(void);
        -:  413:int huft_build(unsigned int *b, unsigned int n, unsigned int s, ush *d, ush *e,
        -:  414:               struct huft **t, int *m);
        -:  415:int huft_free(struct huft *t);
        -:  416:int inflate_codes(struct huft *tl, struct huft *td, int bl, int bd);
        -:  417:int inflate_stored(void);
        -:  418:int inflate_fixed(void);
        -:  419:int inflate_dynamic(void);
        -:  420:int inflate_block(int *e);
        -:  421:static unsigned int border[19] = {16U, 17U, 18U, 0U, 8U,  7U, 9U,  6U, 10U, 5U,
        -:  422:                                  11U, 4U,  12U, 3U, 13U, 2U, 14U, 1U, 15U};
        -:  423:static ush cplens[31] = {
        -:  424:    (ush)3,   (ush)4,  (ush)5,   (ush)6,   (ush)7,   (ush)8,   (ush)9,
        -:  425:    (ush)10,  (ush)11, (ush)13,  (ush)15,  (ush)17,  (ush)19,  (ush)23,
        -:  426:    (ush)27,  (ush)31, (ush)35,  (ush)43,  (ush)51,  (ush)59,  (ush)67,
        -:  427:    (ush)83,  (ush)99, (ush)115, (ush)131, (ush)163, (ush)195, (ush)227,
        -:  428:    (ush)258, (ush)0,  (ush)0};
        -:  429:static ush cplext[31] = {
        -:  430:    (ush)0, (ush)0, (ush)0, (ush)0, (ush)0, (ush)0,  (ush)0, (ush)0,
        -:  431:    (ush)1, (ush)1, (ush)1, (ush)1, (ush)2, (ush)2,  (ush)2, (ush)2,
        -:  432:    (ush)3, (ush)3, (ush)3, (ush)3, (ush)4, (ush)4,  (ush)4, (ush)4,
        -:  433:    (ush)5, (ush)5, (ush)5, (ush)5, (ush)0, (ush)99, (ush)99};
        -:  434:static ush cpdist[30] = {
        -:  435:    (ush)1,    (ush)2,    (ush)3,    (ush)4,     (ush)5,     (ush)7,
        -:  436:    (ush)9,    (ush)13,   (ush)17,   (ush)25,    (ush)33,    (ush)49,
        -:  437:    (ush)65,   (ush)97,   (ush)129,  (ush)193,   (ush)257,   (ush)385,
        -:  438:    (ush)513,  (ush)769,  (ush)1025, (ush)1537,  (ush)2049,  (ush)3073,
        -:  439:    (ush)4097, (ush)6145, (ush)8193, (ush)12289, (ush)16385, (ush)24577};
        -:  440:static ush cpdext[30] = {(ush)0,  (ush)0,  (ush)0,  (ush)0,  (ush)1,  (ush)1,
        -:  441:                         (ush)2,  (ush)2,  (ush)3,  (ush)3,  (ush)4,  (ush)4,
        -:  442:                         (ush)5,  (ush)5,  (ush)6,  (ush)6,  (ush)7,  (ush)7,
        -:  443:                         (ush)8,  (ush)8,  (ush)9,  (ush)9,  (ush)10, (ush)10,
        -:  444:                         (ush)11, (ush)11, (ush)12, (ush)12, (ush)13, (ush)13};
        -:  445:ulg bb;
        -:  446:unsigned int bk;
        -:  447:ush mask_bits[17] = {(ush)0,     (ush)1,    (ush)3,    (ush)7,    (ush)15,
        -:  448:                     (ush)31,    (ush)63,   (ush)127,  (ush)255,  (ush)511,
        -:  449:                     (ush)1023,  (ush)2047, (ush)4095, (ush)8191, (ush)16383,
        -:  450:                     (ush)32767, (ush)65535};
        -:  451:
        -:  452:int dbits = 6;
        -:  453:
    #####:  454:int huft_build(unsigned int *b, unsigned int n, unsigned int s, ush *d, ush *e,
        -:  455:               struct huft **t, int *m) {
        -:  456:  unsigned int a;
        -:  457:  unsigned int c[17];
        -:  458:  unsigned int f;
        -:  459:  int g;
        -:  460:  int h;
        -:  461:  register unsigned int i___0;
        -:  462:  register unsigned int j___0;
        -:  463:  register int k;
        -:  464:  int l;
        -:  465:  register unsigned int *p;
        -:  466:  register struct huft *q;
        -:  467:  struct huft r;
        -:  468:  struct huft *u[16];
        -:  469:  unsigned int v[288];
        -:  470:  register int w;
        -:  471:  unsigned int x[17];
        -:  472:  unsigned int *xp;
        -:  473:
        -:  474:  unsigned int z;
        -:  475:  unsigned int *tmp;
        -:  476:  unsigned int *tmp___0;
        -:  477:  unsigned int tmp___1;
        -:  478:  unsigned int *tmp___2;
        -:  479:  int tmp___4;
        -:  480:  unsigned int *tmp___5;
        -:  481:  unsigned int tmp___6;
        -:  482:  int tmp___7;
        -:  483:
        -:  484:  {
        -:  485:    {
    #####:  486:      memset((voidp)(c), 0, sizeof(c));
    #####:  487:      p = b;
    #####:  488:      i___0 = n;
        -:  489:    }
        -:  490:    {
        -:  491:      while (1) {
        -:  492:        ;
    #####:  493:        (c[*p])++;
    #####:  494:        p++;
    #####:  495:        i___0--;
    #####:  496:        if (!i___0) {
    #####:  497:          goto while_break;
        -:  498:        }
        -:  499:      }
    #####:  500:    while_break: /* CIL Label */;
        -:  501:    }
        -:  502:
    #####:  503:    l = *m;
    #####:  504:    j___0 = 1U;
        -:  505:
    #####:  506:    k = (int)j___0;
        -:  507:
    #####:  508:    i___0 = 16U;
        -:  509:
    #####:  510:    g = (int)i___0;
        -:  511:
    #####:  512:    j___0 = 0U;
        -:  513:
    #####:  514:    p = c + 1;
    #####:  515:    xp = x + 2;
        -:  516:    {
        -:  517:      while (1) {
        -:  518:        ;
    #####:  519:        i___0--;
    #####:  520:        if (!i___0) {
    #####:  521:          goto while_break___3;
        -:  522:        }
    #####:  523:        tmp = xp;
    #####:  524:        xp++;
    #####:  525:        tmp___0 = p;
    #####:  526:        p++;
    #####:  527:        j___0 += *tmp___0;
    #####:  528:        *tmp = j___0;
        -:  529:      }
    #####:  530:    while_break___3: /* CIL Label */;
        -:  531:    }
    #####:  532:    p = b;
        -:  533:
        -:  534:    {
        -:  535:      while (1) {
        -:  536:        ;
    #####:  537:        tmp___2 = p;
    #####:  538:        p++;
    #####:  539:        j___0 = *tmp___2;
    #####:  540:        if (j___0 != 0U) {
    #####:  541:          tmp___1 = x[j___0];
    #####:  542:          (x[j___0])++;
    #####:  543:          v[tmp___1] = i___0;
        -:  544:        }
    #####:  545:        i___0++;
    #####:  546:        if (!(i___0 < n)) {
    #####:  547:          goto while_break___4;
        -:  548:        }
        -:  549:      }
    #####:  550:    while_break___4: /* CIL Label */;
        -:  551:    }
    #####:  552:    i___0 = 0U;
    #####:  553:    x[0] = i___0;
    #####:  554:    p = v;
    #####:  555:    h = -1;
    #####:  556:    w = -l;
        -:  557:
        -:  558:    {
        -:  559:      while (1) {
        -:  560:        ;
    #####:  561:        if (!(k <= g)) {
    #####:  562:          goto while_break___5;
        -:  563:        }
    #####:  564:        a = c[k];
        -:  565:        {
        -:  566:          while (1) {
        -:  567:            ;
    #####:  568:            tmp___6 = a;
    #####:  569:            a--;
    #####:  570:            if (!tmp___6) {
    #####:  571:              goto while_break___6;
        -:  572:            }
        -:  573:            {
        -:  574:              {
        -:  575:                ;
    #####:  576:                if (!(k > w + l)) {
    #####:  577:                  goto while_break___7;
        -:  578:                }
    #####:  579:                h++;
    #####:  580:                w += l;
        -:  581:
    #####:  582:                { z = (unsigned int)l; }
        -:  583:
    #####:  584:                j___0 = (unsigned int)(k - w);
        -:  585:
        -:  586:                {
        -:  587:
        -:  588:                  while (1) {
        -:  589:                    ;
    #####:  590:                    j___0++;
    #####:  591:                    if (!(j___0 < z)) {
    #####:  592:                      goto while_break___8;
        -:  593:                    }
        -:  594:                  }
    #####:  595:                while_break___8: /* CIL Label */;
        -:  596:                }
        -:  597:                {
    #####:  598:                  z = (unsigned int)(1 << j___0);
    #####:  599:                  q = (struct huft *)malloc((unsigned long)(z + 1U) *
        -:  600:                                            sizeof(struct huft));
        -:  601:                }
    #####:  602:                if ((unsigned long)q ==
        -:  603:                    (unsigned long)((struct huft *)((void *)0))) {
        -:  604:
    #####:  605:                  return (3);
        -:  606:                }
        -:  607:
    #####:  608:                *t = q + 1;
    #####:  609:                t = &q->v.t;
        -:  610:
    #####:  611:                q++;
    #####:  612:                u[h] = q;
    #####:  613:                if (h) {
    #####:  614:                  x[h] = i___0;
    #####:  615:                  r.b = (uch)l;
    #####:  616:                  r.e = (uch)(16U + j___0);
    #####:  617:                  r.v.t = q;
    #####:  618:                  j___0 = i___0 >> (w - l);
    #####:  619:                  *(u[h - 1] + j___0) = r;
        -:  620:                }
        -:  621:              }
    #####:  622:            while_break___7: /* CIL Label */;
        -:  623:            }
    #####:  624:            r.b = (uch)(k - w);
        -:  625:
        -:  626:            {
    #####:  627:              if (*p < s) {
    #####:  628:                if (*p < 256U) {
    #####:  629:                  tmp___4 = 16;
        -:  630:                } else {
    #####:  631:                  tmp___4 = 15;
        -:  632:                }
    #####:  633:                r.e = (uch)tmp___4;
    #####:  634:                r.v.n = (ush)*p;
    #####:  635:                p++;
        -:  636:              } else {
    #####:  637:                r.e = (uch) * (e + (*p - s));
    #####:  638:                tmp___5 = p;
    #####:  639:                p++;
    #####:  640:                r.v.n = *(d + (*tmp___5 - s));
        -:  641:              }
        -:  642:            }
    #####:  643:            f = (unsigned int)(1 << (k - w));
    #####:  644:            j___0 = i___0 >> w;
        -:  645:            {
        -:  646:              while (1) {
        -:  647:                ;
    #####:  648:                if (!(j___0 < z)) {
    #####:  649:                  goto while_break___9;
        -:  650:                }
    #####:  651:                *(q + j___0) = r;
    #####:  652:                j___0 += f;
        -:  653:              }
    #####:  654:            while_break___9: /* CIL Label */;
        -:  655:            }
    #####:  656:            j___0 = (unsigned int)(1 << (k - 1));
        -:  657:            {
        -:  658:              while (1) {
        -:  659:                ;
    #####:  660:                if (!(i___0 & j___0)) {
    #####:  661:                  goto while_break___10;
        -:  662:                }
    #####:  663:                i___0 ^= j___0;
    #####:  664:                j___0 >>= 1;
        -:  665:              }
    #####:  666:            while_break___10: /* CIL Label */;
        -:  667:            }
    #####:  668:            i___0 ^= j___0;
        -:  669:            {
        -:  670:              {
        -:  671:                ;
    #####:  672:                if (!((i___0 & (unsigned int)((1 << w) - 1)) != x[h])) {
    #####:  673:                  goto while_break___11;
        -:  674:                }
    #####:  675:                h--;
    #####:  676:                w -= l;
        -:  677:              }
    #####:  678:            while_break___11: /* CIL Label */;
        -:  679:            }
        -:  680:          }
    #####:  681:        while_break___6: /* CIL Label */;
        -:  682:        }
    #####:  683:        k++;
        -:  684:      }
    #####:  685:    while_break___5: /* CIL Label */;
        -:  686:    }
        -:  687:
    #####:  688:    { tmp___7 = 0; }
    #####:  689:    return (tmp___7);
        -:  690:  }
        -:  691:}
        -:  692:
    #####:  693:int inflate_codes(struct huft *tl, struct huft *td, int bl, int bd) {
        -:  694:  register unsigned int e;
        -:  695:  unsigned int n;
        -:  696:  unsigned int d;
        -:  697:  unsigned int w;
        -:  698:  struct huft *t;
        -:  699:  unsigned int ml;
        -:  700:  unsigned int md;
        -:  701:  register ulg b;
        -:  702:  register unsigned int k;
        -:  703:  unsigned int tmp;
        -:  704:
        -:  705:  int tmp___1;
        -:  706:  unsigned int tmp___2;
        -:  707:
        -:  708:  int tmp___4;
        -:  709:  unsigned int tmp___5;
        -:  710:  unsigned int tmp___6;
        -:  711:  int tmp___7;
        -:  712:  int tmp___8;
        -:  713:  unsigned int tmp___9;
        -:  714:
        -:  715:  int tmp___11;
        -:  716:
        -:  717:  unsigned int tmp___15;
        -:  718:
        -:  719:  int tmp___17;
        -:  720:  unsigned int tmp___19;
        -:  721:  unsigned int tmp___20;
        -:  722:  unsigned int tmp___21;
        -:  723:
        -:  724:  {
    #####:  725:    b = bb;
    #####:  726:    k = bk;
    #####:  727:    w = outcnt;
    #####:  728:    ml = (unsigned int)mask_bits[bl];
    #####:  729:    md = (unsigned int)mask_bits[bd];
        -:  730:    {
        -:  731:      while (1) {
        -:  732:        ;
        -:  733:        {
        -:  734:          {
        -:  735:            ;
    #####:  736:            if (!(k < (unsigned int)bl)) {
    #####:  737:              goto while_break___0;
        -:  738:            }
        -:  739:            {
    #####:  740:              tmp = inptr;
    #####:  741:              inptr++;
    #####:  742:              tmp___1 = (int)inbuf[tmp];
        -:  743:            }
        -:  744:
    #####:  745:            b |= (ulg)((uch)tmp___1) << k;
    #####:  746:            k += 8U;
        -:  747:          }
    #####:  748:        while_break___0: /* CIL Label */;
        -:  749:        }
    #####:  750:        t = tl + ((unsigned int)b & ml);
    #####:  751:        e = (unsigned int)t->e;
    #####:  752:        if (e > 16U) {
        -:  753:
        -:  754:          {
        -:  755:            ;
        -:  756:
    #####:  757:            b >>= (int)t->b;
    #####:  758:            k -= (unsigned int)t->b;
    #####:  759:            e -= 16U;
        -:  760:            {
        -:  761:              {
        -:  762:                ;
        -:  763:
        -:  764:                {
    #####:  765:                  tmp___2 = inptr;
    #####:  766:                  inptr++;
    #####:  767:                  tmp___4 = (int)inbuf[tmp___2];
        -:  768:                }
        -:  769:
    #####:  770:                b |= (ulg)((uch)tmp___4) << k;
    #####:  771:                k += 8U;
        -:  772:              };
        -:  773:            }
    #####:  774:            t = t->v.t + ((unsigned int)b & (unsigned int)mask_bits[e]);
    #####:  775:            e = (unsigned int)t->e;
        -:  776:          };
        -:  777:        }
    #####:  778:        b >>= (int)t->b;
    #####:  779:        k -= (unsigned int)t->b;
    #####:  780:        if (e == 16U) {
    #####:  781:          tmp___5 = w;
    #####:  782:          w++;
    #####:  783:          window[tmp___5] = (uch)t->v.n;
    #####:  784:          if (w == 32768U) {
        -:  785:
    #####:  786:            flush_window();
    #####:  787:            w = 0U;
        -:  788:          }
        -:  789:        } else {
    #####:  790:          if (e == 15U) {
    #####:  791:            goto while_break;
        -:  792:          }
        -:  793:          {
        -:  794:            {
        -:  795:              ;
        -:  796:
    #####:  797:              if (inptr < insize) {
    #####:  798:                tmp___6 = inptr;
    #####:  799:                inptr++;
    #####:  800:                tmp___8 = (int)inbuf[tmp___6];
        -:  801:              } else {
        -:  802:
    #####:  803:                tmp___7 = fill_inbuf(0);
    #####:  804:                tmp___8 = tmp___7;
        -:  805:              }
    #####:  806:              b |= (ulg)((uch)tmp___8) << k;
    #####:  807:              k += 8U;
        -:  808:            };
        -:  809:          }
    #####:  810:          n = (unsigned int)t->v.n +
    #####:  811:              ((unsigned int)b & (unsigned int)mask_bits[e]);
    #####:  812:          b >>= e;
    #####:  813:          k -= e;
        -:  814:          {
        -:  815:            {
        -:  816:              ;
        -:  817:
        -:  818:              {
    #####:  819:                tmp___9 = inptr;
    #####:  820:                inptr++;
    #####:  821:                tmp___11 = (int)inbuf[tmp___9];
        -:  822:              }
        -:  823:
    #####:  824:              b |= (ulg)((uch)tmp___11) << k;
    #####:  825:              k += 8U;
        -:  826:            };
        -:  827:          }
    #####:  828:          t = td + ((unsigned int)b & md);
    #####:  829:          e = (unsigned int)t->e;
    #####:  830:          if (e > 16U) {
        -:  831:
        -:  832:            while (1) {
        -:  833:              ;
        -:  834:
    #####:  835:              b >>= (int)t->b;
    #####:  836:              k -= (unsigned int)t->b;
    #####:  837:              e -= 16U;
        -:  838:
    #####:  839:              t = t->v.t + ((unsigned int)b & (unsigned int)mask_bits[e]);
    #####:  840:              e = (unsigned int)t->e;
    #####:  841:              if (!(e > 16U)) {
    #####:  842:                goto while_break___5;
        -:  843:              }
        -:  844:            }
    #####:  845:          while_break___5: /* CIL Label */;
        -:  846:          }
    #####:  847:          b >>= (int)t->b;
    #####:  848:          k -= (unsigned int)t->b;
        -:  849:          {
        -:  850:            {
        -:  851:              ;
    #####:  852:              if (!(k < e)) {
    #####:  853:                goto while_break___7;
        -:  854:              }
        -:  855:              {
    #####:  856:                tmp___15 = inptr;
    #####:  857:                inptr++;
    #####:  858:                tmp___17 = (int)inbuf[tmp___15];
        -:  859:              }
        -:  860:
    #####:  861:              b |= (ulg)((uch)tmp___17) << k;
    #####:  862:              k += 8U;
        -:  863:            }
    #####:  864:          while_break___7: /* CIL Label */;
        -:  865:          }
    #####:  866:          d = (w - (unsigned int)t->v.n) -
    #####:  867:              ((unsigned int)b & (unsigned int)mask_bits[e]);
    #####:  868:          b >>= e;
    #####:  869:          k -= e;
        -:  870:          {
        -:  871:            while (1) {
        -:  872:              ;
    #####:  873:              d &= 32767U;
    #####:  874:              if (d > w) {
    #####:  875:                tmp___19 = d;
        -:  876:              } else {
    #####:  877:                tmp___19 = w;
        -:  878:              }
    #####:  879:              e = 32768U - tmp___19;
    #####:  880:              if (e > n) {
    #####:  881:                e = n;
        -:  882:              } else {
        -:  883:              }
    #####:  884:              n -= e;
        -:  885:
        -:  886:              {
        -:  887:
        -:  888:                while (1) {
        -:  889:                  ;
    #####:  890:                  tmp___20 = w;
    #####:  891:                  w++;
    #####:  892:                  tmp___21 = d;
    #####:  893:                  d++;
    #####:  894:                  window[tmp___20] = window[tmp___21];
    #####:  895:                  e--;
    #####:  896:                  if (!e) {
    #####:  897:                    goto while_break___9;
        -:  898:                  }
        -:  899:                }
    #####:  900:              while_break___9: /* CIL Label */;
        -:  901:              }
    #####:  902:              if (w == 32768U) {
        -:  903:
    #####:  904:                outcnt = w;
    #####:  905:                flush_window();
    #####:  906:                w = 0U;
        -:  907:              }
    #####:  908:              if (!n) {
    #####:  909:                goto while_break___8;
        -:  910:              }
        -:  911:            }
    #####:  912:          while_break___8: /* CIL Label */;
        -:  913:          }
        -:  914:        }
        -:  915:      }
    #####:  916:    while_break: /* CIL Label */;
        -:  917:    }
    #####:  918:    outcnt = w;
    #####:  919:    bb = b;
    #####:  920:    bk = k;
    #####:  921:    return (0);
        -:  922:  }
        -:  923:}
        -:  924:
    #####:  925:int inflate_dynamic(void) {
        -:  926:  int i___0;
        -:  927:  unsigned int j___0;
        -:  928:  unsigned int l;
        -:  929:  unsigned int m;
        -:  930:  unsigned int n;
        -:  931:  struct huft *tl;
        -:  932:  struct huft *td;
        -:  933:  int bl;
        -:  934:  int bd;
        -:  935:  unsigned int nb;
        -:  936:  unsigned int nl;
        -:  937:  unsigned int nd;
        -:  938:  unsigned int ll[316];
        -:  939:  register ulg b;
        -:  940:  register unsigned int k;
        -:  941:  unsigned int tmp;
        -:  942:
        -:  943:  int tmp___1;
        -:  944:
        -:  945:  unsigned int tmp___5;
        -:  946:
        -:  947:  int tmp___7;
        -:  948:  unsigned int tmp___8;
        -:  949:
        -:  950:  int tmp___10;
        -:  951:  unsigned int tmp___11;
        -:  952:
        -:  953:  int tmp___13;
        -:  954:  int tmp___14;
        -:  955:
        -:  956:  int tmp___18;
        -:  957:  unsigned int tmp___19;
        -:  958:
        -:  959:  int tmp___30;
        -:  960:
        -:  961:  {
    #####:  962:    b = bb;
    #####:  963:    k = bk;
        -:  964:    {
        -:  965:      {
        -:  966:        ;
        -:  967:
        -:  968:        {
    #####:  969:          tmp = inptr;
    #####:  970:          inptr++;
    #####:  971:          tmp___1 = (int)inbuf[tmp];
        -:  972:        }
        -:  973:
    #####:  974:        b |= (ulg)((uch)tmp___1) << k;
    #####:  975:        k += 8U;
        -:  976:      };
        -:  977:    }
    #####:  978:    nl = 257U + ((unsigned int)b & 31U);
    #####:  979:    b >>= 5;
    #####:  980:    k -= 5U;
        -:  981:
    #####:  982:    nd = 1U + ((unsigned int)b & 31U);
    #####:  983:    b >>= 5;
    #####:  984:    k -= 5U;
        -:  985:    {
        -:  986:      {
        -:  987:        ;
        -:  988:
        -:  989:        {
    #####:  990:          tmp___5 = inptr;
    #####:  991:          inptr++;
    #####:  992:          tmp___7 = (int)inbuf[tmp___5];
        -:  993:        }
        -:  994:
    #####:  995:        b |= (ulg)((uch)tmp___7) << k;
    #####:  996:        k += 8U;
        -:  997:      };
        -:  998:    }
    #####:  999:    nb = 4U + ((unsigned int)b & 15U);
    #####: 1000:    b >>= 4;
    #####: 1001:    k -= 4U;
        -: 1002:
    #####: 1003:    j___0 = 0U;
        -: 1004:    {
        -: 1005:      while (1) {
        -: 1006:        ;
    #####: 1007:        if (!(j___0 < nb)) {
    #####: 1008:          goto while_break___2;
        -: 1009:        }
        -: 1010:        {
        -: 1011:          {
        -: 1012:            ;
    #####: 1013:            if (!(k < 3U)) {
    #####: 1014:              goto while_break___3;
        -: 1015:            }
        -: 1016:            {
    #####: 1017:              tmp___8 = inptr;
    #####: 1018:              inptr++;
    #####: 1019:              tmp___10 = (int)inbuf[tmp___8];
        -: 1020:            }
        -: 1021:
    #####: 1022:            b |= (ulg)((uch)tmp___10) << k;
    #####: 1023:            k += 8U;
        -: 1024:          }
    #####: 1025:        while_break___3: /* CIL Label */;
        -: 1026:        }
    #####: 1027:        ll[border[j___0]] = (unsigned int)b & 7U;
    #####: 1028:        b >>= 3;
    #####: 1029:        k -= 3U;
    #####: 1030:        j___0++;
        -: 1031:      }
    #####: 1032:    while_break___2: /* CIL Label */;
        -: 1033:    }
        -: 1034:    {
        -: 1035:      while (1) {
        -: 1036:        ;
    #####: 1037:        if (!(j___0 < 19U)) {
    #####: 1038:          goto while_break___4;
        -: 1039:        }
    #####: 1040:        ll[border[j___0]] = 0U;
    #####: 1041:        j___0++;
        -: 1042:      }
    #####: 1043:    while_break___4: /* CIL Label */;
        -: 1044:    }
        -: 1045:    {
    #####: 1046:      bl = 7;
    #####: 1047:      i___0 = huft_build(ll, 19U, 19U, (ush *)((void *)0), (ush *)((void *)0),
        -: 1048:                         &tl, &bl);
        -: 1049:    }
    #####: 1050:    if (i___0 != 0) {
        -: 1051:
    #####: 1052:      return (i___0);
        -: 1053:    }
    #####: 1054:    n = nl + nd;
    #####: 1055:    m = (unsigned int)mask_bits[bl];
        -: 1056:
        -: 1057:    {
        -: 1058:      while (1) {
        -: 1059:        ;
    #####: 1060:        if (!((unsigned int)i___0 < n)) {
    #####: 1061:          goto while_break___5;
        -: 1062:        }
        -: 1063:        {
        -: 1064:          {
        -: 1065:            ;
    #####: 1066:            if (!(k < (unsigned int)bl)) {
    #####: 1067:              goto while_break___6;
        -: 1068:            }
        -: 1069:            {
    #####: 1070:              tmp___11 = inptr;
    #####: 1071:              inptr++;
    #####: 1072:              tmp___13 = (int)inbuf[tmp___11];
        -: 1073:            }
        -: 1074:
    #####: 1075:            b |= (ulg)((uch)tmp___13) << k;
    #####: 1076:            k += 8U;
        -: 1077:          }
    #####: 1078:        while_break___6: /* CIL Label */;
        -: 1079:        }
    #####: 1080:        td = tl + ((unsigned int)b & m);
    #####: 1081:        j___0 = (unsigned int)td->b;
    #####: 1082:        b >>= j___0;
    #####: 1083:        k -= j___0;
    #####: 1084:        j___0 = (unsigned int)td->v.n;
    #####: 1085:        if (j___0 < 16U) {
    #####: 1086:          tmp___14 = i___0;
    #####: 1087:          i___0++;
    #####: 1088:          l = j___0;
    #####: 1089:          ll[tmp___14] = l;
        -: 1090:        } else {
        -: 1091:
    #####: 1092:          j___0 = 3U + ((unsigned int)b & 3U);
    #####: 1093:          b >>= 2;
    #####: 1094:          k -= 2U;
        -: 1095:
        -: 1096:          {
        -: 1097:            while (1) {
        -: 1098:              ;
    #####: 1099:              tmp___19 = j___0;
    #####: 1100:              j___0--;
    #####: 1101:              if (!tmp___19) {
    #####: 1102:                goto while_break___8;
        -: 1103:              }
    #####: 1104:              tmp___18 = i___0;
    #####: 1105:              i___0++;
    #####: 1106:              ll[tmp___18] = l;
        -: 1107:            }
    #####: 1108:          while_break___8: /* CIL Label */;
        -: 1109:          }
        -: 1110:        }
        -: 1111:      }
    #####: 1112:    while_break___5: /* CIL Label */;
        -: 1113:    }
        -: 1114:    {
        -: 1115:
    #####: 1116:      bb = b;
    #####: 1117:      bk = k;
        -: 1118:
    #####: 1119:      i___0 = huft_build(ll, nl, 257U, cplens, cplext, &tl, &bl);
        -: 1120:    }
        -: 1121:
        -: 1122:    {
    #####: 1123:      bd = dbits;
    #####: 1124:      i___0 = huft_build(ll + nl, nd, 0U, cpdist, cpdext, &td, &bd);
        -: 1125:    }
        -: 1126:
    #####: 1127:    { tmp___30 = inflate_codes(tl, td, bl, bd); }
        -: 1128:
    #####: 1129:    return (0);
        -: 1130:  }
        -: 1131:}
    #####: 1132:int inflate_block(int *e) {
        -: 1133:
        -: 1134:  register ulg b;
        -: 1135:  register unsigned int k;
        -: 1136:  unsigned int tmp;
        -: 1137:
        -: 1138:  int tmp___1;
        -: 1139:
        -: 1140:  int tmp___5;
        -: 1141:
        -: 1142:  {
    #####: 1143:    b = bb;
    #####: 1144:    k = bk;
        -: 1145:    {
        -: 1146:      {
        -: 1147:        ;
        -: 1148:
        -: 1149:        {
    #####: 1150:          tmp = inptr;
    #####: 1151:          inptr++;
    #####: 1152:          tmp___1 = (int)inbuf[tmp];
        -: 1153:        }
        -: 1154:
    #####: 1155:        b |= (ulg)((uch)tmp___1) << k;
    #####: 1156:        k += 8U;
        -: 1157:      };
        -: 1158:    }
    #####: 1159:    *e = (int)b & 1;
    #####: 1160:    b >>= 1;
    #####: 1161:    k--;
        -: 1162:
    #####: 1163:    b >>= 2;
    #####: 1164:    k -= 2U;
    #####: 1165:    bb = b;
    #####: 1166:    bk = k;
        -: 1167:    {
    #####: 1168:      { tmp___5 = inflate_dynamic(); }
    #####: 1169:      return (tmp___5);
        -: 1170:    }
        -: 1171:  }
        -: 1172:}
    #####: 1173:int inflate(void) {
        -: 1174:  int e;
        -: 1175:  int r;
        -: 1176:
        -: 1177:  {
        -: 1178:
        -: 1179:    {
        -: 1180:      while (1) {
        -: 1181:        ;
    #####: 1182:        { r = inflate_block(&e); }
    #####: 1183:        if (r != 0) {
    #####: 1184:          return (r);
        -: 1185:        }
        -: 1186:
    #####: 1187:        if (!(!e)) {
    #####: 1188:          goto while_break;
        -: 1189:        }
        -: 1190:      }
    #####: 1191:    while_break: /* CIL Label */;
        -: 1192:    }
        -: 1193:
    #####: 1194:    { flush_window(); }
        -: 1195:  }
    #####: 1196:}
        -: 1197:int method;
        -: 1198:
        -: 1199:int unzip(int in, int out);
        -: 1200:int check_zipfile(int in);
        -: 1201:
    #####: 1202:int unzip(int in, int out) {
        -: 1203:
        -: 1204:  int tmp;
        -: 1205:
        -: 1206:  {
    #####: 1207:    { ofd = out; }
        -: 1208:
        -: 1209:    {
    #####: 1210:      { tmp = inflate(); }
    #####: 1211:      { error((char *)"out of memory"); }
        -: 1212:    }
        -: 1213:
    #####: 1214:    return (0);
        -: 1215:  }
        -: 1216:}
        -: 1217:int file_read(char *buf, unsigned int size);
        -: 1218:void bi_init(file_t zipfile);
        -: 1219:void send_bits(int value, int length);
        -: 1220:unsigned int bi_reverse(unsigned int code, int len);
        -: 1221:void bi_windup(void);
        -: 1222:void copy_block(char *buf, unsigned int len, int header);
        -: 1223:int (*read_buf)(char *buf, unsigned int size);
        -: 1224:
        -: 1225:static unsigned short bi_buf;
        -: 1226:static int bi_valid;
    #####: 1227:void bi_init(file_t zipfile) { read_buf = &file_read; }
    #####: 1228:void send_bits(int value, int length) {
        -: 1229:
        -: 1230:  unsigned int tmp___1;
        -: 1231:  unsigned int tmp___2;
        -: 1232:
        -: 1233:  {
    #####: 1234:    if (bi_valid > (int)(16UL * sizeof(char)) - length) {
    #####: 1235:      bi_buf = (unsigned short)((int)bi_buf | (value << bi_valid));
        -: 1236:
        -: 1237:      {
    #####: 1238:        tmp___1 = outcnt;
    #####: 1239:        outcnt++;
    #####: 1240:        outbuf[tmp___1] = (uch)((int)bi_buf & 255);
        -: 1241:
    #####: 1242:        tmp___2 = outcnt;
    #####: 1243:        outcnt++;
    #####: 1244:        outbuf[tmp___2] = (uch)((int)bi_buf >> 8);
    #####: 1245:        { flush_outbuf(); }
        -: 1246:      }
    #####: 1247:      bi_buf = (unsigned short)((int)((ush)value) >> (16UL * sizeof(char) -
        -: 1248:                                                      (unsigned long)bi_valid));
    #####: 1249:      bi_valid = (int)((unsigned long)bi_valid +
        -: 1250:                       ((unsigned long)length - 16UL * sizeof(char)));
        -: 1251:    } else {
    #####: 1252:      bi_buf = (unsigned short)((int)bi_buf | (value << bi_valid));
    #####: 1253:      bi_valid += length;
        -: 1254:    }
        -: 1255:  }
    #####: 1256:}
    #####: 1257:unsigned int bi_reverse(unsigned int code, int len) {
        -: 1258:  register unsigned int res;
        -: 1259:
        -: 1260:  {
    #####: 1261:    res = 0U;
        -: 1262:    {
        -: 1263:      while (1) {
        -: 1264:        ;
    #####: 1265:        res |= code & 1U;
    #####: 1266:        code >>= 1;
    #####: 1267:        res <<= 1;
    #####: 1268:        len--;
    #####: 1269:        if (!(len > 0)) {
    #####: 1270:          goto while_break;
        -: 1271:        }
        -: 1272:      }
    #####: 1273:    while_break: /* CIL Label */;
        -: 1274:    }
    #####: 1275:    return (res >> 1);
        -: 1276:  }
        -: 1277:}
    #####: 1278:void bi_windup(void) {
        -: 1279:
        -: 1280:  unsigned int tmp___3;
        -: 1281:
        -: 1282:  {
        -: 1283:
    #####: 1284:    tmp___3 = outcnt;
    #####: 1285:    outcnt++;
    #####: 1286:    outbuf[tmp___3] = (uch)bi_buf;
        -: 1287:  }
    #####: 1288:}
        -: 1289:
        -: 1290:int level;
        -: 1291:void ct_init(ush *attr, int *methodp);
        -: 1292:int ct_tally(int dist, int lc);
        -: 1293:ulg flush_block(char *buf, ulg stored_len, int eof);
        -: 1294:static int extra_lbits[29] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2,
        -: 1295:                              2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};
        -: 1296:static int extra_dbits[30] = {0, 0, 0,  0,  1,  1,  2,  2,  3,  3,
        -: 1297:                              4, 4, 5,  5,  6,  6,  7,  7,  8,  8,
        -: 1298:                              9, 9, 10, 10, 11, 11, 12, 12, 13, 13};
        -: 1299:static int extra_blbits[19] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        -: 1300:                               0, 0, 0, 0, 0, 0, 2, 3, 7};
        -: 1301:static ct_data dyn_ltree[573];
        -: 1302:static ct_data dyn_dtree[61];
        -: 1303:static ct_data static_ltree[288];
        -: 1304:static ct_data static_dtree[30];
        -: 1305:static ct_data bl_tree[39];
        -: 1306:static tree_desc l_desc = {dyn_ltree, static_ltree, extra_lbits, 257, 286, 15,
        -: 1307:                           0};
        -: 1308:static tree_desc d_desc = {dyn_dtree, static_dtree, extra_dbits, 0, 30, 15, 0};
        -: 1309:static tree_desc bl_desc = {bl_tree, (ct_data *)0, extra_blbits, 0, 19, 7, 0};
        -: 1310:static ush bl_count[16];
        -: 1311:static uch bl_order[19] = {(uch)16, (uch)17, (uch)18, (uch)0,  (uch)8,
        -: 1312:                           (uch)7,  (uch)9,  (uch)6,  (uch)10, (uch)5,
        -: 1313:                           (uch)11, (uch)4,  (uch)12, (uch)3,  (uch)13,
        -: 1314:                           (uch)2,  (uch)14, (uch)1,  (uch)15};
        -: 1315:static int heap[573];
        -: 1316:static int heap_len;
        -: 1317:static int heap_max;
        -: 1318:static uch depth[573];
        -: 1319:static uch length_code[256];
        -: 1320:static uch dist_code[512];
        -: 1321:static int base_length[29];
        -: 1322:static int base_dist[30];
        -: 1323:static uch flag_buf[4096];
        -: 1324:static unsigned int last_lit;
        -: 1325:static unsigned int last_dist;
        -: 1326:static unsigned int last_flags;
        -: 1327:static uch flags;
        -: 1328:static uch flag_bit;
        -: 1329:
        -: 1330:static ulg compressed_len;
        -: 1331:
        -: 1332:long block_start;
        -: 1333:unsigned int strstart;
        -: 1334:static void init_block(void);
        -: 1335:static void pqdownheap(ct_data *tree, int k);
        -: 1336:static void gen_bitlen(tree_desc *desc);
        -: 1337:static void gen_codes(ct_data *tree, int max_code);
        -: 1338:static void build_tree___0(tree_desc *desc);
        -: 1339:static void scan_tree(ct_data *tree, int max_code);
        -: 1340:static void send_tree(ct_data *tree, int max_code);
        -: 1341:static int build_bl_tree(void);
        -: 1342:static void send_all_trees(int lcodes, int dcodes, int blcodes);
        -: 1343:static void compress_block(ct_data *ltree, ct_data *dtree);
        -: 1344:static void set_file_type(void);
    #####: 1345:void ct_init(ush *attr, int *methodp) {
        -: 1346:  int n;
        -: 1347:
        -: 1348:  int length;
        -: 1349:  int code;
        -: 1350:  int dist;
        -: 1351:  int tmp;
        -: 1352:  int tmp___0;
        -: 1353:  int tmp___1;
        -: 1354:
        -: 1355:  {
        -: 1356:
    #####: 1357:    length = 0;
    #####: 1358:    code = 0;
        -: 1359:    {
        -: 1360:      while (1) {
        -: 1361:        ;
    #####: 1362:        if (!(code < 28)) {
    #####: 1363:          goto while_break;
        -: 1364:        }
    #####: 1365:        base_length[code] = length;
    #####: 1366:        n = 0;
        -: 1367:        {
        -: 1368:          while (1) {
        -: 1369:            ;
    #####: 1370:            if (!(n < 1 << extra_lbits[code])) {
    #####: 1371:              goto while_break___0;
        -: 1372:            }
    #####: 1373:            tmp = length;
    #####: 1374:            length++;
    #####: 1375:            length_code[tmp] = (uch)code;
    #####: 1376:            n++;
        -: 1377:          }
    #####: 1378:        while_break___0: /* CIL Label */;
        -: 1379:        }
    #####: 1380:        code++;
        -: 1381:      }
    #####: 1382:    while_break: /* CIL Label */;
        -: 1383:    }
        -: 1384:
    #####: 1385:    dist = 0;
    #####: 1386:    code = 0;
        -: 1387:    {
        -: 1388:      while (1) {
        -: 1389:        ;
    #####: 1390:        if (!(code < 16)) {
    #####: 1391:          goto while_break___1;
        -: 1392:        }
    #####: 1393:        base_dist[code] = dist;
    #####: 1394:        n = 0;
        -: 1395:        {
        -: 1396:          while (1) {
        -: 1397:            ;
    #####: 1398:            if (!(n < 1 << extra_dbits[code])) {
    #####: 1399:              goto while_break___2;
        -: 1400:            }
    #####: 1401:            tmp___0 = dist;
    #####: 1402:            dist++;
    #####: 1403:            dist_code[tmp___0] = (uch)code;
    #####: 1404:            n++;
        -: 1405:          }
    #####: 1406:        while_break___2: /* CIL Label */;
        -: 1407:        }
    #####: 1408:        code++;
        -: 1409:      }
    #####: 1410:    while_break___1: /* CIL Label */;
        -: 1411:    }
    #####: 1412:    dist >>= 7;
        -: 1413:    {
        -: 1414:      while (1) {
        -: 1415:        ;
    #####: 1416:        if (!(code < 30)) {
    #####: 1417:          goto while_break___3;
        -: 1418:        }
    #####: 1419:        base_dist[code] = dist << 7;
    #####: 1420:        n = 0;
        -: 1421:        {
        -: 1422:          while (1) {
        -: 1423:            ;
    #####: 1424:            if (!(n < 1 << (extra_dbits[code] - 7))) {
    #####: 1425:              goto while_break___4;
        -: 1426:            }
    #####: 1427:            tmp___1 = dist;
    #####: 1428:            dist++;
    #####: 1429:            dist_code[256 + tmp___1] = (uch)code;
    #####: 1430:            n++;
        -: 1431:          }
    #####: 1432:        while_break___4: /* CIL Label */;
        -: 1433:        }
    #####: 1434:        code++;
        -: 1435:      }
    #####: 1436:    while_break___3: /* CIL Label */;
        -: 1437:    }
        -: 1438:
    #####: 1439:    { init_block(); }
        -: 1440:  }
    #####: 1441:}
    #####: 1442:static void init_block(void) {
        -: 1443:  int n;
        -: 1444:
        -: 1445:  {
    #####: 1446:    n = 0;
        -: 1447:    {
        -: 1448:      while (1) {
        -: 1449:        ;
    #####: 1450:        if (!(n < 286)) {
    #####: 1451:          goto while_break;
        -: 1452:        }
    #####: 1453:        dyn_ltree[n].fc.freq = (ush)0;
    #####: 1454:        n++;
        -: 1455:      }
    #####: 1456:    while_break: /* CIL Label */;
        -: 1457:    }
    #####: 1458:    n = 0;
        -: 1459:    {
        -: 1460:      while (1) {
        -: 1461:        ;
    #####: 1462:        if (!(n < 30)) {
    #####: 1463:          goto while_break___0;
        -: 1464:        }
    #####: 1465:        dyn_dtree[n].fc.freq = (ush)0;
    #####: 1466:        n++;
        -: 1467:      }
    #####: 1468:    while_break___0: /* CIL Label */;
        -: 1469:    }
    #####: 1470:    n = 0;
        -: 1471:    {
        -: 1472:      while (1) {
        -: 1473:        ;
    #####: 1474:        if (!(n < 19)) {
    #####: 1475:          goto while_break___1;
        -: 1476:        }
    #####: 1477:        bl_tree[n].fc.freq = (ush)0;
    #####: 1478:        n++;
        -: 1479:      }
    #####: 1480:    while_break___1: /* CIL Label */;
        -: 1481:    }
    #####: 1482:    dyn_ltree[256].fc.freq = (ush)1;
        -: 1483:
    #####: 1484:    last_flags = 0U;
    #####: 1485:    last_dist = last_flags;
    #####: 1486:    last_lit = last_dist;
        -: 1487:  }
    #####: 1488:}
    #####: 1489:static void pqdownheap(ct_data *tree, int k) {
        -: 1490:  int v;
        -: 1491:  int j___0;
        -: 1492:
        -: 1493:  {
    #####: 1494:    v = heap[k];
    #####: 1495:    j___0 = k << 1;
        -: 1496:    {
        -: 1497:      while (1) {
        -: 1498:        ;
    #####: 1499:        if (!(j___0 <= heap_len)) {
    #####: 1500:          goto while_break;
        -: 1501:        }
    #####: 1502:        if (j___0 < heap_len) {
    #####: 1503:          if ((int)(tree + heap[j___0 + 1])->fc.freq <
    #####: 1504:              (int)(tree + heap[j___0])->fc.freq) {
    #####: 1505:            j___0++;
        -: 1506:          } else {
    #####: 1507:            if ((int)(tree + heap[j___0 + 1])->fc.freq ==
    #####: 1508:                (int)(tree + heap[j___0])->fc.freq) {
    #####: 1509:              if ((int)depth[heap[j___0 + 1]] <= (int)depth[heap[j___0]]) {
    #####: 1510:                j___0++;
        -: 1511:              }
        -: 1512:            }
        -: 1513:          }
        -: 1514:        }
    #####: 1515:        if ((int)(tree + v)->fc.freq < (int)(tree + heap[j___0])->fc.freq) {
    #####: 1516:          goto while_break;
        -: 1517:        } else {
    #####: 1518:          if ((int)(tree + v)->fc.freq == (int)(tree + heap[j___0])->fc.freq) {
    #####: 1519:            if ((int)depth[v] <= (int)depth[heap[j___0]]) {
    #####: 1520:              goto while_break;
        -: 1521:            }
        -: 1522:          }
        -: 1523:        }
    #####: 1524:        heap[k] = heap[j___0];
    #####: 1525:        k = j___0;
    #####: 1526:        j___0 <<= 1;
        -: 1527:      }
    #####: 1528:    while_break: /* CIL Label */;
        -: 1529:    }
    #####: 1530:    heap[k] = v;
        -: 1531:  }
    #####: 1532:}
    #####: 1533:static void gen_bitlen(tree_desc *desc) {
        -: 1534:  ct_data *tree;
        -: 1535:
        -: 1536:  int max_code;
        -: 1537:
        -: 1538:  int h;
        -: 1539:  int n;
        -: 1540:
        -: 1541:  int bits;
        -: 1542:
        -: 1543:  {
    #####: 1544:    tree = desc->dyn_tree;
        -: 1545:
    #####: 1546:    max_code = desc->max_code;
        -: 1547:
    #####: 1548:    bits = 0;
        -: 1549:    {
        -: 1550:      while (1) {
        -: 1551:        ;
    #####: 1552:        if (!(bits <= 15)) {
    #####: 1553:          goto while_break;
        -: 1554:        }
    #####: 1555:        bl_count[bits] = (ush)0;
    #####: 1556:        bits++;
        -: 1557:      }
    #####: 1558:    while_break: /* CIL Label */;
        -: 1559:    }
        -: 1560:
    #####: 1561:    h = heap_max + 1;
        -: 1562:    {
        -: 1563:      while (1) {
        -: 1564:        ;
    #####: 1565:        if (!(h < 573)) {
    #####: 1566:          goto while_break___0;
        -: 1567:        }
    #####: 1568:        n = heap[h];
    #####: 1569:        bits = (int)(tree + (int)(tree + n)->dl.dad)->dl.len + 1;
        -: 1570:
    #####: 1571:        (tree + n)->dl.len = (ush)bits;
    #####: 1572:        if (n > max_code) {
    #####: 1573:          goto __Cont;
        -: 1574:        }
    #####: 1575:        bl_count[bits] = (ush)((int)bl_count[bits] + 1);
        -: 1576:
    #####: 1577:      __Cont:
    #####: 1578:        h++;
        -: 1579:      }
    #####: 1580:    while_break___0: /* CIL Label */;
        -: 1581:    }
        -: 1582:  }
    #####: 1583:}
    #####: 1584:static void gen_codes(ct_data *tree, int max_code) {
        -: 1585:  ush next_code[16];
        -: 1586:  ush code;
        -: 1587:  int bits;
        -: 1588:  int n;
        -: 1589:  int len;
        -: 1590:  ush tmp;
        -: 1591:
        -: 1592:  {
        -: 1593:
    #####: 1594:    bits = 1;
        -: 1595:    {
        -: 1596:      while (1) {
        -: 1597:        ;
    #####: 1598:        if (!(bits <= 15)) {
    #####: 1599:          goto while_break;
        -: 1600:        }
    #####: 1601:        code = (ush)(((int)code + (int)bl_count[bits - 1]) << 1);
    #####: 1602:        next_code[bits] = code;
    #####: 1603:        bits++;
        -: 1604:      }
    #####: 1605:    while_break: /* CIL Label */;
        -: 1606:    }
    #####: 1607:    n = 0;
        -: 1608:    {
        -: 1609:      while (1) {
        -: 1610:        ;
    #####: 1611:        if (!(n <= max_code)) {
    #####: 1612:          goto while_break___0;
        -: 1613:        }
    #####: 1614:        len = (int)(tree + n)->dl.len;
        -: 1615:
        -: 1616:        {
    #####: 1617:          tmp = next_code[len];
    #####: 1618:          next_code[len] = (ush)((int)next_code[len] + 1);
    #####: 1619:          (tree + n)->fc.code = (ush)bi_reverse((unsigned int)tmp, len);
        -: 1620:        }
        -: 1621:
    #####: 1622:        n++;
        -: 1623:      }
    #####: 1624:    while_break___0: /* CIL Label */;
        -: 1625:    }
        -: 1626:  }
    #####: 1627:}
    #####: 1628:static void build_tree___0(tree_desc *desc) {
        -: 1629:  ct_data *tree;
        -: 1630:
        -: 1631:  int elems;
        -: 1632:  int n;
        -: 1633:  int m;
        -: 1634:  int max_code;
        -: 1635:  int node;
        -: 1636:
        -: 1637:  int tmp___0;
        -: 1638:  int tmp___1;
        -: 1639:  ush tmp___2;
        -: 1640:  int tmp___3;
        -: 1641:
        -: 1642:  {
    #####: 1643:    tree = desc->dyn_tree;
        -: 1644:
    #####: 1645:    elems = desc->elems;
        -: 1646:
    #####: 1647:    node = elems;
    #####: 1648:    heap_len = 0;
    #####: 1649:    heap_max = 573;
    #####: 1650:    n = 0;
        -: 1651:    {
        -: 1652:      while (1) {
        -: 1653:        ;
    #####: 1654:        if (!(n < elems)) {
    #####: 1655:          goto while_break;
        -: 1656:        }
    #####: 1657:        if ((int)(tree + n)->fc.freq != 0) {
    #####: 1658:          heap_len++;
    #####: 1659:          max_code = n;
    #####: 1660:          heap[heap_len] = max_code;
        -: 1661:
        -: 1662:        } else {
    #####: 1663:          (tree + n)->dl.len = (ush)0;
        -: 1664:        }
    #####: 1665:        n++;
        -: 1666:      }
    #####: 1667:    while_break: /* CIL Label */;
        -: 1668:    }
        -: 1669:
    #####: 1670:    desc->max_code = max_code;
        -: 1671:
        -: 1672:    {
        -: 1673:      while (1) {
        -: 1674:        ;
    #####: 1675:        if (!(n >= 1)) {
    #####: 1676:          goto while_break___1;
        -: 1677:        }
        -: 1678:        {
    #####: 1679:          pqdownheap(tree, n);
    #####: 1680:          n--;
        -: 1681:        }
        -: 1682:      }
    #####: 1683:    while_break___1: /* CIL Label */;
        -: 1684:    }
        -: 1685:    {
        -: 1686:      while (1) {
        -: 1687:        ;
        -: 1688:        {
    #####: 1689:          n = heap[1];
    #####: 1690:          tmp___0 = heap_len;
    #####: 1691:          heap_len--;
    #####: 1692:          heap[1] = heap[tmp___0];
    #####: 1693:          pqdownheap(tree, 1);
    #####: 1694:          m = heap[1];
    #####: 1695:          heap_max--;
    #####: 1696:          heap[heap_max] = n;
    #####: 1697:          heap_max--;
    #####: 1698:          heap[heap_max] = m;
    #####: 1699:          (tree + node)->fc.freq =
    #####: 1700:              (ush)((int)(tree + n)->fc.freq + (int)(tree + m)->fc.freq);
        -: 1701:        }
    #####: 1702:        { tmp___1 = (int)depth[n]; }
        -: 1703:
        -: 1704:        {
    #####: 1705:          depth[node] = (uch)(tmp___1 + 1);
    #####: 1706:          tmp___2 = (ush)node;
    #####: 1707:          (tree + m)->dl.dad = tmp___2;
    #####: 1708:          (tree + n)->dl.dad = tmp___2;
    #####: 1709:          tmp___3 = node;
    #####: 1710:          node++;
    #####: 1711:          heap[1] = tmp___3;
    #####: 1712:          pqdownheap(tree, 1);
        -: 1713:        }
    #####: 1714:        if (!(heap_len >= 2)) {
    #####: 1715:          goto while_break___2;
        -: 1716:        }
        -: 1717:      }
    #####: 1718:    while_break___2: /* CIL Label */;
        -: 1719:    }
        -: 1720:    {
    #####: 1721:      heap_max--;
        -: 1722:
    #####: 1723:      gen_bitlen(desc);
    #####: 1724:      gen_codes(tree, max_code);
        -: 1725:    }
        -: 1726:  }
    #####: 1727:}
    #####: 1728:static void scan_tree(ct_data *tree, int max_code) {
        -: 1729:  int n;
        -: 1730:
        -: 1731:  int curlen;
        -: 1732:  int nextlen;
        -: 1733:  int count;
        -: 1734:  int max_count;
        -: 1735:  int min_count;
        -: 1736:
        -: 1737:  {
        -: 1738:
    #####: 1739:    nextlen = (int)(tree + 0)->dl.len;
    #####: 1740:    count = 0;
    #####: 1741:    max_count = 7;
    #####: 1742:    min_count = 4;
        -: 1743:
    #####: 1744:    n = 0;
        -: 1745:    {
        -: 1746:      while (1) {
        -: 1747:        ;
    #####: 1748:        if (!(n <= max_code)) {
    #####: 1749:          goto while_break;
        -: 1750:        }
    #####: 1751:        curlen = nextlen;
    #####: 1752:        nextlen = (int)(tree + (n + 1))->dl.len;
    #####: 1753:        count++;
    #####: 1754:        if (count < max_count) {
    #####: 1755:          if (curlen == nextlen) {
    #####: 1756:            goto __Cont;
        -: 1757:          } else {
    #####: 1758:            goto _L;
        -: 1759:          }
        -: 1760:        } else {
    #####: 1761:        _L:
    #####: 1762:          if (count < min_count) {
    #####: 1763:            bl_tree[curlen].fc.freq =
    #####: 1764:                (ush)((int)bl_tree[curlen].fc.freq + count);
        -: 1765:          } else {
        -: 1766:
        -: 1767:            {
    #####: 1768:              bl_tree[curlen].fc.freq = (ush)((int)bl_tree[curlen].fc.freq + 1);
        -: 1769:            }
    #####: 1770:            bl_tree[16].fc.freq = (ush)((int)bl_tree[16].fc.freq + 1);
        -: 1771:          }
        -: 1772:        }
    #####: 1773:        count = 0;
        -: 1774:
    #####: 1775:      __Cont:
    #####: 1776:        n++;
        -: 1777:      }
    #####: 1778:    while_break: /* CIL Label */;
        -: 1779:    }
        -: 1780:  }
    #####: 1781:}
    #####: 1782:static void send_tree(ct_data *tree, int max_code) {
        -: 1783:  int n;
        -: 1784:
        -: 1785:  int curlen;
        -: 1786:  int nextlen;
        -: 1787:  int count;
        -: 1788:  int max_count;
        -: 1789:  int min_count;
        -: 1790:
        -: 1791:  {
        -: 1792:
    #####: 1793:    nextlen = (int)(tree + 0)->dl.len;
    #####: 1794:    count = 0;
    #####: 1795:    max_count = 7;
    #####: 1796:    min_count = 4;
        -: 1797:
    #####: 1798:    n = 0;
        -: 1799:    {
        -: 1800:      while (1) {
        -: 1801:        ;
    #####: 1802:        if (!(n <= max_code)) {
    #####: 1803:          goto while_break;
        -: 1804:        }
    #####: 1805:        curlen = nextlen;
    #####: 1806:        nextlen = (int)(tree + (n + 1))->dl.len;
    #####: 1807:        count++;
    #####: 1808:        if (count < max_count) {
    #####: 1809:          if (curlen == nextlen) {
    #####: 1810:            goto __Cont;
        -: 1811:          } else {
    #####: 1812:            goto _L;
        -: 1813:          }
        -: 1814:        } else {
    #####: 1815:        _L:
    #####: 1816:          if (count < min_count) {
        -: 1817:
        -: 1818:            while (1) {
        -: 1819:              ;
        -: 1820:              {
    #####: 1821:                send_bits((int)bl_tree[curlen].fc.code,
    #####: 1822:                          (int)bl_tree[curlen].dl.len);
    #####: 1823:                count--;
        -: 1824:              }
    #####: 1825:              if (!(count != 0)) {
    #####: 1826:                goto while_break___0;
        -: 1827:              }
        -: 1828:            }
    #####: 1829:          while_break___0: /* CIL Label */;
        -: 1830:
        -: 1831:          } else {
        -: 1832:
        -: 1833:            {
        -: 1834:
    #####: 1835:              send_bits((int)bl_tree[curlen].fc.code,
    #####: 1836:                        (int)bl_tree[curlen].dl.len);
    #####: 1837:              count--;
        -: 1838:            }
        -: 1839:            {
    #####: 1840:              send_bits((int)bl_tree[16].fc.code, (int)bl_tree[16].dl.len);
    #####: 1841:              send_bits(count - 3, 2);
        -: 1842:            }
        -: 1843:          }
        -: 1844:        }
    #####: 1845:        count = 0;
        -: 1846:
    #####: 1847:      __Cont:
    #####: 1848:        n++;
        -: 1849:      }
    #####: 1850:    while_break: /* CIL Label */;
        -: 1851:    }
        -: 1852:  }
    #####: 1853:}
    #####: 1854:static int build_bl_tree(void) {
        -: 1855:  int max_blindex;
        -: 1856:
        -: 1857:  {
        -: 1858:    {
    #####: 1859:      scan_tree(dyn_ltree, l_desc.max_code);
    #####: 1860:      scan_tree(dyn_dtree, d_desc.max_code);
    #####: 1861:      build_tree___0(&bl_desc);
    #####: 1862:      max_blindex = 18;
        -: 1863:    }
        -: 1864:    {
        -: 1865:      while (1) {
        -: 1866:        ;
        -: 1867:
    #####: 1868:        if ((int)bl_tree[bl_order[max_blindex]].dl.len != 0) {
    #####: 1869:          goto while_break;
        -: 1870:        }
    #####: 1871:        max_blindex--;
        -: 1872:      }
    #####: 1873:    while_break: /* CIL Label */;
        -: 1874:    }
        -: 1875:
    #####: 1876:    return (max_blindex);
        -: 1877:  }
        -: 1878:}
    #####: 1879:static void send_all_trees(int lcodes, int dcodes, int blcodes) {
        -: 1880:  int rank;
        -: 1881:
        -: 1882:  {
        -: 1883:    {
    #####: 1884:      send_bits(lcodes - 257, 5);
    #####: 1885:      send_bits(dcodes - 1, 5);
    #####: 1886:      send_bits(blcodes - 4, 4);
    #####: 1887:      rank = 0;
        -: 1888:    }
        -: 1889:    {
        -: 1890:      while (1) {
        -: 1891:        ;
    #####: 1892:        if (!(rank < blcodes)) {
    #####: 1893:          goto while_break;
        -: 1894:        }
        -: 1895:        {
    #####: 1896:          send_bits((int)bl_tree[bl_order[rank]].dl.len, 3);
    #####: 1897:          rank++;
        -: 1898:        }
        -: 1899:      }
    #####: 1900:    while_break: /* CIL Label */;
        -: 1901:    }
        -: 1902:    {
    #####: 1903:      send_tree(dyn_ltree, lcodes - 1);
    #####: 1904:      send_tree(dyn_dtree, dcodes - 1);
        -: 1905:    }
        -: 1906:  }
    #####: 1907:}
    #####: 1908:ulg flush_block(char *buf, ulg stored_len, int eof) {
        -: 1909:
        -: 1910:  int max_blindex;
        -: 1911:
        -: 1912:  {
    #####: 1913:    flag_buf[last_flags] = flags;
        -: 1914:
        -: 1915:    {
    #####: 1916:      build_tree___0(&l_desc);
    #####: 1917:      build_tree___0(&d_desc);
    #####: 1918:      max_blindex = build_bl_tree();
        -: 1919:    }
        -: 1920:
        -: 1921:    {
        -: 1922:
    #####: 1923:      send_bits((2 << 1) + eof, 3);
    #####: 1924:      send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
    #####: 1925:      compress_block(dyn_ltree, dyn_dtree);
        -: 1926:    }
    #####: 1927:    { init_block(); }
    #####: 1928:    if (eof) {
        -: 1929:
    #####: 1930:      bi_windup();
        -: 1931:    }
    #####: 1932:    return (compressed_len >> 3);
        -: 1933:  }
        -: 1934:}
    #####: 1935:int ct_tally(int dist, int lc) {
        -: 1936:  unsigned int tmp;
        -: 1937:  int tmp___0;
        -: 1938:  unsigned int tmp___1;
        -: 1939:  unsigned int tmp___2;
        -: 1940:  ulg out_length;
        -: 1941:  ulg in_length;
        -: 1942:  int dcode;
        -: 1943:  int tmp___3;
        -: 1944:
        -: 1945:  {
    #####: 1946:    tmp = last_lit;
    #####: 1947:    last_lit++;
    #####: 1948:    inbuf[tmp] = (uch)lc;
    #####: 1949:    if (dist == 0) {
    #####: 1950:      dyn_ltree[lc].fc.freq = (ush)((int)dyn_ltree[lc].fc.freq + 1);
        -: 1951:    } else {
    #####: 1952:      dist--;
    #####: 1953:      dyn_ltree[((int)length_code[lc] + 256) + 1].fc.freq =
    #####: 1954:          (ush)((int)dyn_ltree[((int)length_code[lc] + 256) + 1].fc.freq + 1);
    #####: 1955:      if (dist < 256) {
    #####: 1956:        tmp___0 = (int)dist_code[dist];
        -: 1957:      } else {
    #####: 1958:        tmp___0 = (int)dist_code[256 + (dist >> 7)];
        -: 1959:      }
    #####: 1960:      dyn_dtree[tmp___0].fc.freq = (ush)((int)dyn_dtree[tmp___0].fc.freq + 1);
    #####: 1961:      tmp___1 = last_dist;
    #####: 1962:      last_dist++;
    #####: 1963:      d_buf[tmp___1] = (ush)dist;
    #####: 1964:      flags = (uch)((int)flags | (int)flag_bit);
        -: 1965:    }
    #####: 1966:    flag_bit = (uch)((int)flag_bit << 1);
    #####: 1967:    if ((last_lit & 7U) == 0U) {
    #####: 1968:      tmp___2 = last_flags;
    #####: 1969:      last_flags++;
    #####: 1970:      flag_buf[tmp___2] = flags;
    #####: 1971:      flags = (uch)0;
    #####: 1972:      flag_bit = (uch)1;
        -: 1973:    }
        -: 1974:    {
    #####: 1975:      if ((last_lit & 4095U) == 0U) {
    #####: 1976:        out_length = (ulg)last_lit * 8UL;
    #####: 1977:        in_length = (ulg)strstart - (ulg)block_start;
    #####: 1978:        dcode = 0;
        -: 1979:        {
        -: 1980:          while (1) {
        -: 1981:            ;
    #####: 1982:            if (!(dcode < 30)) {
    #####: 1983:              goto while_break;
        -: 1984:            }
    #####: 1985:            out_length += (ulg)dyn_dtree[dcode].fc.freq *
    #####: 1986:                          (ulg)(5L + (long)extra_dbits[dcode]);
    #####: 1987:            dcode++;
        -: 1988:          }
    #####: 1989:        while_break: /* CIL Label */;
        -: 1990:        }
    #####: 1991:        out_length >>= 3;
    #####: 1992:        if (last_dist < last_lit / 2U) {
    #####: 1993:          if (out_length < in_length / 2UL) {
    #####: 1994:            return (1);
        -: 1995:          }
        -: 1996:        }
        -: 1997:      }
        -: 1998:    }
        -: 1999:
    #####: 2000:    { tmp___3 = 0; }
    #####: 2001:    return (tmp___3);
        -: 2002:  }
        -: 2003:}
    #####: 2004:static void compress_block(ct_data *ltree, ct_data *dtree) {
        -: 2005:  unsigned int dist;
        -: 2006:  int lc;
        -: 2007:  unsigned int lx;
        -: 2008:  unsigned int dx;
        -: 2009:  unsigned int fx;
        -: 2010:  uch flag;
        -: 2011:  unsigned int code;
        -: 2012:  int extra;
        -: 2013:  unsigned int tmp;
        -: 2014:  unsigned int tmp___0;
        -: 2015:  unsigned int tmp___1;
        -: 2016:
        -: 2017:  {
    #####: 2018:    lx = 0U;
    #####: 2019:    dx = 0U;
    #####: 2020:    fx = 0U;
        -: 2021:
        -: 2022:    {
        -: 2023:
        -: 2024:      while (1) {
        -: 2025:        ;
    #####: 2026:        if ((lx & 7U) == 0U) {
    #####: 2027:          tmp = fx;
    #####: 2028:          fx++;
    #####: 2029:          flag = flag_buf[tmp];
        -: 2030:        }
    #####: 2031:        tmp___0 = lx;
    #####: 2032:        lx++;
    #####: 2033:        lc = (int)inbuf[tmp___0];
    #####: 2034:        if (((int)flag & 1) == 0) {
        -: 2035:
    #####: 2036:          send_bits((int)(ltree + lc)->fc.code, (int)(ltree + lc)->dl.len);
        -: 2037:
        -: 2038:        } else {
        -: 2039:          {
    #####: 2040:            code = (unsigned int)length_code[lc];
    #####: 2041:            send_bits((int)(ltree + ((code + 256U) + 1U))->fc.code,
    #####: 2042:                      (int)(ltree + ((code + 256U) + 1U))->dl.len);
    #####: 2043:            extra = extra_lbits[code];
        -: 2044:          }
        -: 2045:          {
        -: 2046:
    #####: 2047:            lc -= base_length[code];
    #####: 2048:            send_bits(lc, extra);
        -: 2049:          }
    #####: 2050:          tmp___1 = dx;
    #####: 2051:          dx++;
    #####: 2052:          dist = (unsigned int)d_buf[tmp___1];
    #####: 2053:          if (dist < 256U) {
    #####: 2054:            code = (unsigned int)dist_code[dist];
        -: 2055:          } else {
    #####: 2056:            code = (unsigned int)dist_code[256U + (dist >> 7)];
        -: 2057:          }
        -: 2058:          {
    #####: 2059:            send_bits((int)(dtree + code)->fc.code,
    #####: 2060:                      (int)(dtree + code)->dl.len);
    #####: 2061:            extra = extra_dbits[code];
        -: 2062:          }
        -: 2063:          {
        -: 2064:
    #####: 2065:            dist -= (unsigned int)base_dist[code];
    #####: 2066:            send_bits((int)dist, extra);
        -: 2067:          }
        -: 2068:        }
    #####: 2069:        flag = (uch)((int)flag >> 1);
    #####: 2070:        if (!(lx < last_lit)) {
    #####: 2071:          goto while_break;
        -: 2072:        }
        -: 2073:      }
    #####: 2074:    while_break: /* CIL Label */;
        -: 2075:    }
    #####: 2076:    { send_bits((int)(ltree + 256)->fc.code, (int)(ltree + 256)->dl.len); }
        -: 2077:  }
    #####: 2078:}
        -: 2079:
        -: 2080:void lm_init(int pack_level, ush *flags___0);
        -: 2081:ulg deflate(void);
        -: 2082:ulg window_size = 65536UL;
        -: 2083:static unsigned int ins_h;
        -: 2084:unsigned int prev_length;
        -: 2085:unsigned int match_start;
        -: 2086:
        -: 2087:static unsigned int lookahead;
        -: 2088:unsigned int max_chain_length;
        -: 2089:static unsigned int max_lazy_match;
        -: 2090:
        -: 2091:unsigned int good_match;
        -: 2092:
        -: 2093:static config configuration_table[10] = {
        -: 2094:    {(ush)0, (ush)0, (ush)0, (ush)0},
        -: 2095:    {(ush)4, (ush)4, (ush)8, (ush)4},
        -: 2096:    {(ush)4, (ush)5, (ush)16, (ush)8},
        -: 2097:    {(ush)4, (ush)6, (ush)32, (ush)32},
        -: 2098:    {(ush)4, (ush)4, (ush)16, (ush)16},
        -: 2099:    {(ush)8, (ush)16, (ush)32, (ush)32},
        -: 2100:    {(ush)8, (ush)16, (ush)128, (ush)128},
        -: 2101:    {(ush)8, (ush)32, (ush)128, (ush)256},
        -: 2102:    {(ush)32, (ush)128, (ush)258, (ush)1024},
        -: 2103:    {(ush)32, (ush)258, (ush)258, (ush)4096}};
        -: 2104:static void fill_window(void);
        -: 2105:static ulg deflate_fast(void);
        -: 2106:int longest_match(IPos cur_match);
    #####: 2107:void lm_init(int pack_level, ush *flags___0) {
        -: 2108:
        -: 2109:  unsigned int tmp;
        -: 2110:
        -: 2111:  {
        -: 2112:
        -: 2113:    {
        -: 2114:
    #####: 2115:      max_lazy_match = (unsigned int)configuration_table[pack_level].max_lazy;
    #####: 2116:      good_match = (unsigned int)configuration_table[pack_level].good_length;
        -: 2117:
    #####: 2118:      max_chain_length =
    #####: 2119:          (unsigned int)configuration_table[pack_level].max_chain;
        -: 2120:    }
        -: 2121:
    #####: 2122:    { tmp = 32768U; }
        -: 2123:
    #####: 2124:    { lookahead = (unsigned int)(*read_buf)((char *)(window), tmp); }
        -: 2125:  }
    #####: 2126:}
    #####: 2127:int longest_match(IPos cur_match) {
        -: 2128:  unsigned int chain_length;
        -: 2129:  register uch *scan;
        -: 2130:  register uch *match;
        -: 2131:  register int len;
        -: 2132:  int best_len;
        -: 2133:  IPos limit;
        -: 2134:  unsigned int tmp;
        -: 2135:  register uch *strend;
        -: 2136:
        -: 2137:  {
    #####: 2138:    chain_length = max_chain_length;
    #####: 2139:    scan = window + strstart;
    #####: 2140:    best_len = (int)prev_length;
    #####: 2141:    if (strstart > 32506U) {
    #####: 2142:      tmp = strstart - 32506U;
        -: 2143:    } else {
    #####: 2144:      tmp = 0U;
        -: 2145:    }
    #####: 2146:    limit = tmp;
    #####: 2147:    strend = (window + strstart) + 258;
        -: 2148:
    #####: 2149:    if (prev_length >= good_match) {
    #####: 2150:      chain_length >>= 2;
        -: 2151:    }
        -: 2152:    {
        -: 2153:      while (1) {
        -: 2154:        ;
    #####: 2155:        match = window + cur_match;
        -: 2156:
        -: 2157:        {
        -: 2158:
    #####: 2159:          if ((int)*match != (int)*scan) {
    #####: 2160:            goto __Cont;
        -: 2161:          } else {
    #####: 2162:            match++;
        -: 2163:          }
        -: 2164:        }
    #####: 2165:        scan += 2;
    #####: 2166:        match++;
        -: 2167:        {
        -: 2168:          while (1) {
        -: 2169:            ;
        -: 2170:
        -: 2171:            {
        -: 2172:
    #####: 2173:              if ((int)*scan == (int)*match) {
        -: 2174:
    #####: 2175:                scan++;
    #####: 2176:                match++;
        -: 2177:
        -: 2178:              } else {
    #####: 2179:                goto while_break___0;
        -: 2180:              }
        -: 2181:            }
        -: 2182:          }
    #####: 2183:        while_break___0: /* CIL Label */;
        -: 2184:        }
    #####: 2185:        len = 258 - (int)(strend - scan);
    #####: 2186:        scan = strend - 258;
    #####: 2187:        if (len > best_len) {
    #####: 2188:          match_start = cur_match;
    #####: 2189:          best_len = len;
        -: 2190:        }
    #####: 2191:      __Cont:
    #####: 2192:        cur_match = (IPos)prev[cur_match & 32767U];
    #####: 2193:        if (cur_match > limit) {
    #####: 2194:          chain_length--;
    #####: 2195:          if (!(chain_length != 0U)) {
    #####: 2196:            goto while_break;
        -: 2197:          }
        -: 2198:        } else {
    #####: 2199:          goto while_break;
        -: 2200:        }
        -: 2201:      }
    #####: 2202:    while_break: /* CIL Label */;
        -: 2203:    }
    #####: 2204:    return (best_len);
        -: 2205:  }
        -: 2206:}
    #####: 2207:static void fill_window(void) {
        -: 2208:  register unsigned int n;
        -: 2209:  register unsigned int m;
        -: 2210:  unsigned int more;
        -: 2211:  unsigned int tmp;
        -: 2212:  unsigned int tmp___0;
        -: 2213:
        -: 2214:  {
    #####: 2215:    more = (unsigned int)((window_size - (ulg)lookahead) - (ulg)strstart);
        -: 2216:
        -: 2217:    {
    #####: 2218:      if (strstart >= 65274U) {
        -: 2219:        {
    #####: 2220:          memcpy((void * /* __restrict  */)((char *)(window)),
        -: 2221:                 (void const * /* __restrict  */)((char *)(window) + 32768),
        -: 2222:                 (size_t)32768U);
        -: 2223:
    #####: 2224:          strstart -= 32768U;
        -: 2225:
    #####: 2226:          n = 0U;
        -: 2227:        }
        -: 2228:        {
        -: 2229:          while (1) {
        -: 2230:            ;
    #####: 2231:            if (!(n < (unsigned int)(1 << 15))) {
    #####: 2232:              goto while_break;
        -: 2233:            }
    #####: 2234:            m = (unsigned int)*((prev + 32768) + n);
    #####: 2235:            { tmp = m - 32768U; }
        -: 2236:
    #####: 2237:            *((prev + 32768) + n) = (Pos)tmp;
    #####: 2238:            n++;
        -: 2239:          }
    #####: 2240:        while_break: /* CIL Label */;
        -: 2241:        }
    #####: 2242:        n = 0U;
        -: 2243:        {
        -: 2244:          while (1) {
        -: 2245:            ;
    #####: 2246:            if (!(n < 32768U)) {
    #####: 2247:              goto while_break___0;
        -: 2248:            }
    #####: 2249:            m = (unsigned int)prev[n];
    #####: 2250:            { tmp___0 = m - 32768U; }
        -: 2251:
    #####: 2252:            prev[n] = (Pos)tmp___0;
    #####: 2253:            n++;
        -: 2254:          }
    #####: 2255:        while_break___0: /* CIL Label */;
        -: 2256:        }
        -: 2257:      }
        -: 2258:    }
        -: 2259:    {
        -: 2260:      {
    #####: 2261:        n = (unsigned int)(*read_buf)(((char *)(window) + strstart) + lookahead,
        -: 2262:                                      more);
        -: 2263:      }
        -: 2264:
    #####: 2265:      { lookahead += n; }
        -: 2266:    }
        -: 2267:  }
    #####: 2268:}
        -: 2269:
    #####: 2270:ulg deflate(void) {
        -: 2271:  IPos hash_head;
        -: 2272:  IPos prev_match;
        -: 2273:  int flush;
        -: 2274:  int match_available;
        -: 2275:  register unsigned int match_length;
        -: 2276:
        -: 2277:  char *tmp___1;
        -: 2278:  int tmp___2;
        -: 2279:  char *tmp___3;
        -: 2280:  ulg tmp___4;
        -: 2281:
        -: 2282:  {
    #####: 2283:    match_available = 0;
    #####: 2284:    match_length = 2U;
        -: 2285:
        -: 2286:    {
        -: 2287:      while (1) {
        -: 2288:        ;
    #####: 2289:        if (!(lookahead != 0U)) {
    #####: 2290:          goto while_break;
        -: 2291:        }
    #####: 2292:        ins_h = ((ins_h << 5) ^ (unsigned int)window[(strstart + 3U) - 1U]) &
        -: 2293:                ((unsigned int)(1 << 15) - 1U);
    #####: 2294:        hash_head = (IPos) * ((prev + 32768) + ins_h);
    #####: 2295:        prev[strstart & 32767U] = (ush)hash_head;
    #####: 2296:        *((prev + 32768) + ins_h) = (ush)strstart;
    #####: 2297:        prev_length = match_length;
    #####: 2298:        prev_match = match_start;
        -: 2299:
    #####: 2300:        if (hash_head != 0U) {
    #####: 2301:          if (prev_length < max_lazy_match) {
    #####: 2302:            if (strstart - hash_head <= 32506U) {
        -: 2303:              {
    #####: 2304:                match_length = (unsigned int)longest_match(hash_head);
        -: 2305:              }
        -: 2306:
    #####: 2307:              if (match_length == 3U) {
    #####: 2308:                if (strstart - match_start > 4096U) {
    #####: 2309:                  match_length--;
        -: 2310:                }
        -: 2311:              }
        -: 2312:            }
        -: 2313:          }
        -: 2314:        }
    #####: 2315:        if (prev_length >= 3U) {
    #####: 2316:          if (match_length <= prev_length) {
        -: 2317:            {
    #####: 2318:              flush = ct_tally((int)((strstart - 1U) - prev_match),
    #####: 2319:                               (int)(prev_length - 3U));
    #####: 2320:              lookahead -= prev_length - 1U;
    #####: 2321:              prev_length -= 2U;
        -: 2322:            }
        -: 2323:            {
        -: 2324:              while (1) {
        -: 2325:                ;
    #####: 2326:                strstart++;
    #####: 2327:                ins_h = ((ins_h << 5) ^
    #####: 2328:                         (unsigned int)window[(strstart + 3U) - 1U]) &
        -: 2329:                        ((unsigned int)(1 << 15) - 1U);
    #####: 2330:                hash_head = (IPos) * ((prev + 32768) + ins_h);
    #####: 2331:                prev[strstart & 32767U] = (ush)hash_head;
    #####: 2332:                *((prev + 32768) + ins_h) = (ush)strstart;
    #####: 2333:                prev_length--;
    #####: 2334:                if (!(prev_length != 0U)) {
    #####: 2335:                  goto while_break___0;
        -: 2336:                }
        -: 2337:              }
    #####: 2338:            while_break___0: /* CIL Label */;
        -: 2339:            }
    #####: 2340:            match_available = 0;
    #####: 2341:            match_length = 2U;
    #####: 2342:            strstart++;
        -: 2343:
        -: 2344:          } else {
    #####: 2345:            goto _L;
        -: 2346:          }
        -: 2347:        } else {
    #####: 2348:        _L:
    #####: 2349:          if (match_available) {
        -: 2350:            {
    #####: 2351:              tmp___2 = ct_tally(0, (int)window[strstart - 1U]);
        -: 2352:            }
    #####: 2353:            if (tmp___2) {
        -: 2354:              {
    #####: 2355:                tmp___1 = (char *)(&window[(unsigned int)block_start]);
        -: 2356:              }
        -: 2357:
    #####: 2358:              { flush_block(tmp___1, (ulg)((long)strstart - block_start), 0); }
        -: 2359:            }
    #####: 2360:            strstart++;
    #####: 2361:            lookahead--;
        -: 2362:          } else {
    #####: 2363:            match_available = 1;
    #####: 2364:            strstart++;
    #####: 2365:            lookahead--;
        -: 2366:          }
        -: 2367:        }
        -: 2368:        {
        -: 2369:          {
        -: 2370:            ;
        -: 2371:
    #####: 2372:            { fill_window(); }
        -: 2373:          };
        -: 2374:        }
        -: 2375:      }
    #####: 2376:    while_break: /* CIL Label */;
        -: 2377:    }
        -: 2378:
    #####: 2379:    { tmp___3 = (char *)(&window[(unsigned int)block_start]); }
        -: 2380:
    #####: 2381:    { tmp___4 = flush_block(tmp___3, (ulg)((long)strstart - block_start), 1); }
    #####: 2382:    return (tmp___4);
        -: 2383:  }
        -: 2384:}
        -: 2385:
        -: 2386:long time_stamp;
        -: 2387:
        -: 2388:int zip(int in, int out);
        -: 2389:static ulg crc___0;
    #####: 2390:int zip(int in, int out) {
        -: 2391:
        -: 2392:  ush attr;
        -: 2393:  ush deflate_flags;
        -: 2394:  unsigned int tmp;
        -: 2395:  unsigned int tmp___0;
        -: 2396:  unsigned int tmp___1;
        -: 2397:
        -: 2398:  unsigned int tmp___3;
        -: 2399:  unsigned int tmp___4;
        -: 2400:
        -: 2401:  unsigned int tmp___7;
        -: 2402:  unsigned int tmp___8;
        -: 2403:
        -: 2404:  unsigned int tmp___12;
        -: 2405:
        -: 2406:  unsigned int tmp___16;
        -: 2407:  unsigned int tmp___17;
        -: 2408:
        -: 2409:  unsigned int tmp___20;
        -: 2410:  unsigned int tmp___21;
        -: 2411:
        -: 2412:  unsigned int tmp___24;
        -: 2413:  unsigned int tmp___25;
        -: 2414:
        -: 2415:  unsigned int tmp___28;
        -: 2416:
        -: 2417:  {
        -: 2418:
    #####: 2419:    ofd = out;
        -: 2420:
    #####: 2421:    tmp = outcnt;
    #####: 2422:    outcnt++;
    #####: 2423:    outbuf[tmp] = (uch) * ("\037\213" + 0);
        -: 2424:
    #####: 2425:    tmp___0 = outcnt;
    #####: 2426:    outcnt++;
    #####: 2427:    outbuf[tmp___0] = (uch) * ("\037\213" + 1);
        -: 2428:
    #####: 2429:    tmp___1 = outcnt;
    #####: 2430:    outcnt++;
    #####: 2431:    outbuf[tmp___1] = (uch)8;
        -: 2432:
    #####: 2433:    outcnt++;
        -: 2434:
        -: 2435:    {
    #####: 2436:      tmp___3 = outcnt;
    #####: 2437:      outcnt++;
    #####: 2438:      outbuf[tmp___3] = (uch)((time_stamp & 65535L) & 255L);
    #####: 2439:      tmp___4 = outcnt;
    #####: 2440:      outcnt++;
    #####: 2441:      outbuf[tmp___4] = (uch)((int)((ush)(time_stamp & 65535L)) >> 8);
        -: 2442:    }
        -: 2443:
        -: 2444:    {
    #####: 2445:      tmp___7 = outcnt;
    #####: 2446:      outcnt++;
    #####: 2447:      outbuf[tmp___7] = (uch)(((ulg)time_stamp >> 16) & 255UL);
    #####: 2448:      tmp___8 = outcnt;
    #####: 2449:      outcnt++;
    #####: 2450:      outbuf[tmp___8] = (uch)((int)((ush)((ulg)time_stamp >> 16)) >> 8);
        -: 2451:    }
        -: 2452:
        -: 2453:    {
        -: 2454:
    #####: 2455:      bi_init(out);
    #####: 2456:      ct_init(&attr, &method);
    #####: 2457:      lm_init(level, &deflate_flags);
        -: 2458:
    #####: 2459:      outcnt++;
        -: 2460:    }
        -: 2461:
    #####: 2462:    tmp___12 = outcnt;
    #####: 2463:    outcnt++;
    #####: 2464:    outbuf[tmp___12] = (uch)3;
        -: 2465:
    #####: 2466:    { deflate(); }
        -: 2467:    {
    #####: 2468:      tmp___16 = outcnt;
    #####: 2469:      outcnt++;
    #####: 2470:      outbuf[tmp___16] = (uch)((crc___0 & 65535UL) & 255UL);
    #####: 2471:      tmp___17 = outcnt;
    #####: 2472:      outcnt++;
    #####: 2473:      outbuf[tmp___17] = (uch)((int)((ush)(crc___0 & 65535UL)) >> 8);
        -: 2474:    }
        -: 2475:
        -: 2476:    {
    #####: 2477:      tmp___20 = outcnt;
    #####: 2478:      outcnt++;
    #####: 2479:      outbuf[tmp___20] = (uch)((crc___0 >> 16) & 255UL);
    #####: 2480:      tmp___21 = outcnt;
    #####: 2481:      outcnt++;
    #####: 2482:      outbuf[tmp___21] = (uch)((int)((ush)(crc___0 >> 16)) >> 8);
        -: 2483:    }
        -: 2484:
        -: 2485:    {
    #####: 2486:      tmp___24 = outcnt;
    #####: 2487:      outcnt++;
    #####: 2488:      outbuf[tmp___24] = (uch)((bytes_in & 65535L) & 255L);
    #####: 2489:      tmp___25 = outcnt;
    #####: 2490:      outcnt++;
    #####: 2491:      outbuf[tmp___25] = (uch)((int)((ush)(bytes_in & 65535L)) >> 8);
        -: 2492:    }
        -: 2493:
        -: 2494:    {
    #####: 2495:      tmp___28 = outcnt;
    #####: 2496:      outcnt++;
    #####: 2497:      outbuf[tmp___28] = (uch)(((ulg)bytes_in >> 16) & 255UL);
        -: 2498:
    #####: 2499:      outcnt++;
        -: 2500:    }
        -: 2501:
    #####: 2502:    { flush_outbuf(); }
    #####: 2503:    return (0);
        -: 2504:  }
        -: 2505:}
    #####: 2506:int file_read(char *buf, unsigned int size) {
        -: 2507:  unsigned int len;
        -: 2508:
        -: 2509:  {
    #####: 2510:    { len = (unsigned int)read(ifd, (void *)buf, (size_t)size); }
        -: 2511:
        -: 2512:    {
    #####: 2513:      crc___0 = updcrc((uch *)buf, len);
    #####: 2514:      bytes_in = (long)((ulg)bytes_in + (ulg)len);
        -: 2515:    }
    #####: 2516:    return ((int)len);
        -: 2517:  }
        -: 2518:}
        -: 2519:static char *license_msg[15] = {
        -: 2520:    (char *)"   Copyright (C) 1992-1993 Jean-loup Gailly",
        -: 2521:    (char *)"   This program is free software; you can redistribute it and/or "
        -: 2522:            "modify",
        -: 2523:    (char *)"   it under the terms of the GNU General Public License as "
        -: 2524:            "published by",
        -: 2525:    (char *)"   the Free Software Foundation; either version 2, or (at your "
        -: 2526:            "option)",
        -: 2527:    (char *)"   any later version.",
        -: 2528:    (char *)"",
        -: 2529:    (char
        -: 2530:         *)"   This program is distributed in the hope that it will be useful,",
        -: 2531:    (char *)"   but WITHOUT ANY WARRANTY; without even the implied warranty of",
        -: 2532:    (char *)"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
        -: 2533:    (char *)"   GNU General Public License for more details.",
        -: 2534:    (char *)"",
        -: 2535:    (char *)"   You should have received a copy of the GNU General Public "
        -: 2536:            "License",
        -: 2537:    (char *)"   along with this program; if not, write to the Free Software",
        -: 2538:    (char *)"   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.",
        -: 2539:    (char *)0};
        -: 2540:extern __attribute__((__nothrow__))
        -: 2541:__sighandler_t(__attribute__((__leaf__)) signal)(int __sig,
        -: 2542:                                                 void (*__handler)(int));
        -: 2543:extern __attribute__((__nothrow__)) int(
        -: 2544:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 2545:    stat)(char const *__restrict __file, struct stat *__restrict __buf);
        -: 2546:extern
        -: 2547:    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(2), __leaf__))
        -: 2548:                                     fstat)(int __fd, struct stat *__buf);
        -: 2549:extern __attribute__((__nothrow__)) int(
        -: 2550:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 2551:    lstat)(char const *__restrict __file, struct stat *__restrict __buf);
        -: 2552:extern
        -: 2553:    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
        -: 2554:                                     chmod)(char const *__file,
        -: 2555:                                            __mode_t __mode);
        -: 2556:extern struct _IO_FILE *stdin;
        -: 2557:extern struct _IO_FILE *stdout;
        -: 2558:extern int fflush(FILE *__stream);
        -: 2559:extern int printf(char const *__restrict __format, ...);
        -: 2560:extern char *fgets(char *__restrict __s, int __n, FILE *__restrict __stream);
        -: 2561:extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
        -: 2562:                                        fileno)(FILE *__stream);
        -: 2563:extern __attribute__((__nothrow__)) int(
        -: 2564:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 2565:    memcmp)(void const *__s1, void const *__s2, size_t __n)
        -: 2566:    __attribute__((__pure__));
        -: 2567:extern __attribute__((__nothrow__)) char *(
        -: 2568:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 2569:    strncpy)(char *__restrict __dest, char const *__restrict __src, size_t __n);
        -: 2570:extern __attribute__((__nothrow__)) char *(
        -: 2571:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 2572:    strcat)(char *__restrict __dest, char const *__restrict __src);
        -: 2573:extern __attribute__((__nothrow__)) int(
        -: 2574:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 2575:    strcmp)(char const *__s1, char const *__s2) __attribute__((__pure__));
        -: 2576:extern __attribute__((__nothrow__)) int(
        -: 2577:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 2578:    strncmp)(char const *__s1, char const *__s2, size_t __n)
        -: 2579:    __attribute__((__pure__));
        -: 2580:
        -: 2581:extern int optind;
        -: 2582:extern int getopt_long(int argc, char *const *argv, char const *shortopts,
        -: 2583:                       struct option const *longopts, int *longind);
        -: 2584:extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__))
        -: 2585:                                           ctime)(time_t const *__timer);
        -: 2586:extern int(__attribute__((__nonnull__(1))) open)(char const *__file,
        -: 2587:                                                 int __oflag, ...);
        -: 2588:extern __attribute__((__nothrow__))
        -: 2589:__off_t(__attribute__((__leaf__)) lseek)(int __fd, __off_t __offset,
        -: 2590:                                         int __whence);
        -: 2591:extern int close(int __fd);
        -: 2592:extern
        -: 2593:    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
        -: 2594:                                     chown)(char const *__file, __uid_t __owner,
        -: 2595:                                            __gid_t __group);
        -: 2596:extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
        -: 2597:                                        isatty)(int __fd);
        -: 2598:extern
        -: 2599:    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
        -: 2600:                                     unlink)(char const *__name);
        -: 2601:extern
        -: 2602:    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
        -: 2603:                                     atoi)(char const *__nptr)
        -: 2604:        __attribute__((__pure__));
        -: 2605:extern __attribute__((__nothrow__, __noreturn__)) void(__attribute__((__leaf__))
        -: 2606:                                                       exit)(int __status);
        -: 2607:extern DIR *(__attribute__((__nonnull__(1))) opendir)(char const *__name);
        -: 2608:extern int(__attribute__((__nonnull__(1))) closedir)(DIR *__dirp);
        -: 2609:extern struct dirent *(__attribute__((__nonnull__(1))) readdir)(DIR *__dirp);
        -: 2610:extern
        -: 2611:    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
        -: 2612:                                     utime)(char const *__file,
        -: 2613:                                            struct utimbuf const *__file_times);
        -: 2614:
        -: 2615:int decompress = 0;
        -: 2616:
        -: 2617:int method = 8;
        -: 2618:int level = 6;
        -: 2619:int exit_code = 0;
        -: 2620:
        -: 2621:struct stat istat;
        -: 2622:struct option longopts[24] = {
        -: 2623:    {"ascii", 0, (int *)0, 'a'},      {"to-stdout", 0, (int *)0, 'c'},
        -: 2624:    {"stdout", 0, (int *)0, 'c'},     {"decompress", 0, (int *)0, 'd'},
        -: 2625:    {"uncompress", 0, (int *)0, 'd'}, {"force", 0, (int *)0, 'f'},
        -: 2626:    {"help", 0, (int *)0, 'h'},       {"list", 0, (int *)0, 'l'},
        -: 2627:    {"license", 0, (int *)0, 'L'},    {"no-name", 0, (int *)0, 'n'},
        -: 2628:    {"name", 0, (int *)0, 'N'},       {"quiet", 0, (int *)0, 'q'},
        -: 2629:    {"silent", 0, (int *)0, 'q'},     {"recursive", 0, (int *)0, 'r'},
        -: 2630:    {"suffix", 1, (int *)0, 'S'},     {"test", 0, (int *)0, 't'},
        -: 2631:    {"no-time", 0, (int *)0, 'T'},    {"verbose", 0, (int *)0, 'v'},
        -: 2632:    {"version", 0, (int *)0, 'V'},    {"fast", 0, (int *)0, '1'},
        -: 2633:    {"best", 0, (int *)0, '9'},       {"lzw", 0, (int *)0, 'Z'},
        -: 2634:    {"bits", 1, (int *)0, 'b'},       {(char const *)0, 0, (int *)0, 0}};
        -: 2635:static void usage(void);
        -: 2636:static void help(void);
        -: 2637:static void license(void);
        -: 2638:static void version(void);
        -: 2639:static void treat_stdin(void);
        -: 2640:static void treat_file(char *iname);
        -: 2641:static int create_outfile(void);
        -: 2642:static int do_stat(char *name, struct stat *sbuf);
        -: 2643:static char *get_suffix(char *name);
        -: 2644:static int get_istat(char *iname, struct stat *sbuf);
        -: 2645:static int make_ofname(void);
        -: 2646:static int same_file(struct stat *stat1, struct stat *stat2);
        -: 2647:static int name_too_long(char *name, struct stat *statb);
        -: 2648:static void shorten_name(char *name);
        -: 2649:static int get_method(int in);
        -: 2650:static void do_list(int ifd___0, int method___0);
        -: 2651:static int check_ofname(void);
        -: 2652:static void copy_stat(struct stat *ifstat);
        -: 2653:static void do_exit(int exitcode);
        -: 2654:int main(int argc, char **argv);
        -: 2655:int (*work)(int infile, int outfile) = &zip;
        -: 2656:static void treat_dir(char *dir);
        -: 2657:static void reset_times(char *name, struct stat *statb);
        -: 2658:
        -: 2659:static char *help_msg[18] = {
        -: 2660:    (char *)" -c --stdout      write on standard output, keep original files "
        -: 2661:            "unchanged",
        -: 2662:    (char *)" -d --decompress  decompress",
        -: 2663:    (char *)" -f --force       force overwrite of output file and compress "
        -: 2664:            "links",
        -: 2665:    (char *)" -h --help        give this help",
        -: 2666:    (char *)" -l --list        list compressed file contents",
        -: 2667:    (char *)" -L --license     display software license",
        -: 2668:    (char *)" -n --no-name     do not save or restore the original name and "
        -: 2669:            "time stamp",
        -: 2670:    (char
        -: 2671:         *)" -N --name        save or restore the original name and time stamp",
        -: 2672:    (char *)" -q --quiet       suppress all warnings",
        -: 2673:    (char *)" -r --recursive   operate recursively on directories",
        -: 2674:    (char *)" -S .suf  --suffix .suf     use suffix .suf on compressed files",
        -: 2675:    (char *)" -t --test        test compressed file integrity",
        -: 2676:    (char *)" -v --verbose     verbose mode",
        -: 2677:    (char *)" -V --version     display version number",
        -: 2678:    (char *)" -1 --fast        compress faster",
        -: 2679:    (char *)" -9 --best        compress better",
        -: 2680:    (char *)" file...          files to (de)compress. If none given, use "
        -: 2681:            "standard input.",
        -: 2682:    (char *)0};
    #####: 2683:static void help(void) {
        -: 2684:  char **p;
        -: 2685:  char **tmp;
        -: 2686:
        -: 2687:  {
    #####: 2688:    { p = help_msg; }
        -: 2689:    {
        -: 2690:      while (1) {
        -: 2691:        ;
    #####: 2692:        if (!*p) {
    #####: 2693:          goto while_break;
        -: 2694:        }
        -: 2695:        {
    #####: 2696:          tmp = p;
    #####: 2697:          p++;
    #####: 2698:          fprintf((FILE * /* __restrict  */) stderr,
        -: 2699:                  (char const * /* __restrict  */) "%s\n", *tmp);
        -: 2700:        }
        -: 2701:      }
    #####: 2702:    while_break: /* CIL Label */;
        -: 2703:    }
        -: 2704:  }
    #####: 2705:}
    #####: 2706:static void license(void) {
        -: 2707:  char **p;
        -: 2708:  char **tmp;
        -: 2709:
        -: 2710:  {
    #####: 2711:    { p = license_msg; }
        -: 2712:    {
        -: 2713:      while (1) {
        -: 2714:        ;
    #####: 2715:        if (!*p) {
    #####: 2716:          goto while_break;
        -: 2717:        }
        -: 2718:        {
    #####: 2719:          tmp = p;
    #####: 2720:          p++;
    #####: 2721:          fprintf((FILE * /* __restrict  */) stderr,
        -: 2722:                  (char const * /* __restrict  */) "%s\n", *tmp);
        -: 2723:        }
        -: 2724:      }
    #####: 2725:    while_break: /* CIL Label */;
        -: 2726:    }
        -: 2727:  }
    #####: 2728:}
    #####: 2729:static void version(void) {
        -: 2730:
    #####: 2731:  fprintf((FILE * /* __restrict  */) stderr,
        -: 2732:          (char const * /* __restrict  */) "%s %s (%s)\n", progname, "1.2.4",
        -: 2733:          "18 Aug 93");
    #####: 2734:  fprintf((FILE * /* __restrict  */) stderr,
        -: 2735:          (char const * /* __restrict  */) "Compilation options:\n%s %s ",
        -: 2736:          "DIRENT", "UTIME");
    #####: 2737:  fprintf((FILE * /* __restrict  */) stderr,
        -: 2738:          (char const * /* __restrict  */) "STDC_HEADERS ");
    #####: 2739:  fprintf((FILE * /* __restrict  */) stderr,
        -: 2740:          (char const * /* __restrict  */) "HAVE_UNISTD_H ");
    #####: 2741:  fprintf((FILE * /* __restrict  */) stderr,
        -: 2742:          (char const * /* __restrict  */) "\n");
    #####: 2743:}
        1: 2744:int main(int argc, char **argv) {
        -: 2745:  int file_count;
        -: 2746:
        -: 2747:  int optc;
        -: 2748:
        -: 2749:  int tmp___8;
        -: 2750:
        -: 2751:  {
        1: 2752:    { progname = basename(*(argv + 0)); }
        -: 2753:
        -: 2754:    {
        -: 2755:      {
        -: 2756:        ;
        -: 2757:        {
        1: 2758:          optc = getopt_long(argc, (char *const *)argv,
        -: 2759:                             "ab:cdfhH?lLmMnNqrS:tvVZ123456789",
        -: 2760:                             (struct option const *)(longopts), (int *)0);
        -: 2761:        }
        -: 2762:
        -: 2763:        {
        -: 2764:
        1: 2765:          if (optc == 100) {
    #####: 2766:            goto case_100;
        -: 2767:          }
        -: 2768:
        1: 2769:          if (optc == 104) {
    #####: 2770:            goto case_104;
        -: 2771:          }
        -: 2772:
        1: 2773:          if (optc == 63) {
    #####: 2774:            goto case_104;
        -: 2775:          }
        -: 2776:
        1: 2777:          if (optc == 76) {
    #####: 2778:            goto case_76;
        -: 2779:          }
        -: 2780:
        1: 2781:          if (optc == 86) {
    #####: 2782:            goto case_86;
        -: 2783:          }
        -: 2784:
        1: 2785:          goto switch_break;
    #####: 2786:        case_100: /* CIL Label */
    #####: 2787:          decompress = 1;
    #####: 2788:          goto switch_break;
        -: 2789:
    #####: 2790:        case_104 : /* CIL Label */
        -: 2791:
        -: 2792:        {
    #####: 2793:          help();
    #####: 2794:          do_exit(0);
        -: 2795:        }
        -: 2796:
    #####: 2797:        case_76 : /* CIL Label */
        -: 2798:        {
    #####: 2799:          license();
    #####: 2800:          do_exit(0);
        -: 2801:        }
        -: 2802:
    #####: 2803:        case_86 : /* CIL Label */
        -: 2804:        {
    #####: 2805:          version();
        -: 2806:        }
        -: 2807:
        1: 2808:        switch_break: /* CIL Label */;
        -: 2809:        }
        -: 2810:      };
        -: 2811:    }
        -: 2812:
        1: 2813:    file_count = argc - optind;
        -: 2814:
        1: 2815:    if (file_count != 0) {
        -: 2816:
        -: 2817:      {
        -: 2818:        ;
        -: 2819:
        -: 2820:        {
    #####: 2821:          tmp___8 = optind;
        -: 2822:
    #####: 2823:          treat_file(*(argv + tmp___8));
        -: 2824:        }
        -: 2825:      };
        -: 2826:
        -: 2827:    } else {
        1: 2828:      treat_stdin();
        -: 2829:    }
        -: 2830:
    #####: 2831:    return (exit_code);
        -: 2832:  }
        -: 2833:}
        1: 2834:static void treat_stdin(void) {
        -: 2835:  char const *tmp;
        -: 2836:  char const *tmp___0;
        -: 2837:  struct _IO_FILE *tmp___1;
        -: 2838:  int tmp___2;
        -: 2839:  int tmp___3;
        -: 2840:
        -: 2841:  int tmp___6;
        -: 2842:  int tmp___7;
        -: 2843:  int tmp___8;
        -: 2844:  int tmp___9;
        -: 2845:  int tmp___10;
        -: 2846:
        -: 2847:  {
        -: 2848:    {
        -: 2849:
        1: 2850:      { tmp___1 = stdout; }
        -: 2851:      {
        1: 2852:        tmp___2 = fileno(tmp___1);
        1: 2853:        tmp___3 = isatty(tmp___2);
        -: 2854:      }
        1: 2855:      if (tmp___3) {
        -: 2856:
        -: 2857:        {
        1: 2858:          tmp = "";
        -: 2859:        }
        -: 2860:
        1: 2861:        { tmp___0 = "written to"; }
        -: 2862:        {
        1: 2863:          fprintf((FILE * /* __restrict  */) stderr,
        -: 2864:                  (char const * /* __restrict  */) "%s: compressed data not "
        -: 2865:                                                   "%s a terminal. Use -f to "
        -: 2866:                                                   "force %scompression.\n",
        -: 2867:                  progname, tmp___0, tmp);
        1: 2868:          fprintf((FILE * /* __restrict  */) stderr,
        -: 2869:                  (char const * /* __restrict  */) "For help, type: %s -h\n",
        -: 2870:                  progname);
        1: 2871:          do_exit(1);
        -: 2872:        }
        -: 2873:      }
        -: 2874:    }
        -: 2875:
        -: 2876:    {
        -: 2877:
        -: 2878:      {
    #####: 2879:        tmp___6 = fileno(stdin);
    #####: 2880:        tmp___7 = fstat(tmp___6, &istat);
        -: 2881:      }
        -: 2882:
    #####: 2883:      time_stamp = istat.st_mtim.tv_sec;
        -: 2884:    }
        -: 2885:
    #####: 2886:    if (decompress) {
        -: 2887:
    #####: 2888:      method = get_method(ifd);
        -: 2889:    }
        -: 2890:
        -: 2891:    {
        -: 2892:      {
        -: 2893:        ;
        -: 2894:        {
    #####: 2895:          tmp___8 = fileno(stdout);
    #####: 2896:          tmp___9 = fileno(stdin);
    #####: 2897:          tmp___10 = (*work)(tmp___9, tmp___8);
        -: 2898:        }
        -: 2899:      };
        -: 2900:    }
        -: 2901:  }
    #####: 2902:}
    #####: 2903:static void treat_file(char *iname) {
        -: 2904:
        -: 2905:  int tmp___0;
        -: 2906:
        -: 2907:  int tmp___3;
        -: 2908:
        -: 2909:  int tmp___11;
        -: 2910:
        -: 2911:  {
        -: 2912:
    #####: 2913:    { tmp___0 = get_istat(iname, &istat); }
        -: 2914:
    #####: 2915:    { tmp___3 = 0; }
        -: 2916:
    #####: 2917:    { ifd = open((char const *)(ifname), tmp___3, 384); }
        -: 2918:
        -: 2919:    {
    #####: 2920:      { method = get_method(ifd); }
    #####: 2921:      if (method < 0) {
        -: 2922:
    #####: 2923:        return;
        -: 2924:      }
        -: 2925:    }
        -: 2926:
        -: 2927:    {
        -: 2928:      {
        -: 2929:        ;
    #####: 2930:        { tmp___11 = (*work)(ifd, ofd); }
        -: 2931:      };
        -: 2932:    }
        -: 2933:  }
        -: 2934:}
        -: 2935:
    #####: 2936:static int get_istat(char *iname, struct stat *sbuf) {
        -: 2937:
        -: 2938:  {
        -: 2939:
    #####: 2940:    strcpy((char * /* __restrict  */)(ifname),
        -: 2941:           (char const * /* __restrict  */)iname);
        -: 2942:  }
    #####: 2943:  { return (0); }
        -: 2944:}
        -: 2945:
    #####: 2946:static int get_method(int in) {
        -: 2947:
        -: 2948:  int tmp___6;
        -: 2949:
        -: 2950:  unsigned int tmp___11;
        -: 2951:
        -: 2952:  int tmp___13;
        -: 2953:
        -: 2954:  {
        -: 2955:
        -: 2956:    {
        -: 2957:
        -: 2958:        {
        -: 2959:
    #####: 2960:            tmp___6 = fill_inbuf(0);
        -: 2961:  }
        -: 2962:
    #####: 2963:  { inptr++; }
        -: 2964:}
        -: 2965:
        -: 2966:{
        -: 2967:
        -: 2968:  {
    #####: 2969:    tmp___11 = inptr;
    #####: 2970:    inptr++;
    #####: 2971:    tmp___13 = (int)inbuf[tmp___11];
        -: 2972:  }
        -: 2973:
    #####: 2974:  method = tmp___13;
    #####: 2975:  if (method != 8) {
        -: 2976:    {
        -: 2977:
    #####: 2978:      exit_code = 1;
        -: 2979:    }
    #####: 2980:    return (-1);
        -: 2981:  }
    #####: 2982:  work = &unzip;
    #####: 2983:  { inptr++; }
        -: 2984:
    #####: 2985:  { inptr++; }
        -: 2986:
    #####: 2987:  { inptr++; }
        -: 2988:
    #####: 2989:  { inptr++; }
        -: 2990:
    #####: 2991:  { inptr++; }
        -: 2992:
    #####: 2993:  { inptr++; }
        -: 2994:
    #####: 2995:  { inptr++; }
        -: 2996:}
        -: 2997:}
    #####: 2998:}
        -: 2999:
        1: 3000:static void do_exit(int exitcode) { exit(exitcode); }
